{
  "project_name": "store_management",
  "total_files": 189,
  "files": {
    "application.py": {
      "path": "application.py",
      "imports": [
        "typing.Type",
        "typing.TypeVar",
        "store_management.di.config.ApplicationConfig",
        "store_management.di.container.DependencyContainer"
      ],
      "classes": [
        {
          "name": "Application",
          "docstring": "Main application class that manages dependency injection and service resolution.\n\nThis class is responsible for initializing the application's dependency container\nand providing access to application services.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the Application instance.\n\nSets up the dependency injection container using ApplicationConfig.",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_service",
              "docstring": "Retrieve a service instance from the dependency container.\n\nArgs:\n    service_type: The type of service to retrieve.\n\nReturns:\n    An instance of the requested service.\n\nRaises:\n    ValueError: If the service cannot be resolved.",
              "args": [
                "self",
                "service_type"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": [
        "T"
      ]
    },
    "config.py": {
      "path": "config.py",
      "imports": [
        "pathlib.Path",
        "os"
      ],
      "classes": [],
      "functions": [
        {
          "name": "get_database_path",
          "docstring": "Returns the absolute path to the database file.\n\nReturns:\n    Path: The absolute path to the database file.",
          "args": []
        }
      ],
      "global_variables": [
        "APP_NAME",
        "WINDOW_SIZE",
        "APP_VERSION",
        "CONFIG_DIR",
        "DATABASE_FILENAME",
        "_DATABASE_PATH",
        "TABLES",
        "COLORS",
        "DEFAULT_PADDING",
        "MINIMUM_COLUMN_WIDTH",
        "DEFAULT_FONT",
        "HEADER_FONT",
        "BACKUP_DIR",
        "LOG_DIR"
      ]
    },
    "import_test.py": {
      "path": "import_test.py",
      "imports": [
        "sys",
        "os"
      ],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "main.py": {
      "path": "main.py",
      "imports": [
        "tkinter",
        "sys",
        "os",
        "store_management.application.Application",
        "store_management.gui.main_window.MainWindow",
        "store_management.di.config.ApplicationConfig"
      ],
      "classes": [],
      "functions": [
        {
          "name": "main",
          "docstring": "Main entry point of the application.\n\nThis function initializes the main application window and starts the GUI event loop.",
          "args": []
        }
      ],
      "global_variables": [
        "project_root"
      ]
    },
    "project_analyzer.py": {
      "path": "project_analyzer.py",
      "imports": [
        "os",
        "ast",
        "json",
        "typing.Dict",
        "typing.List",
        "dataclasses.dataclass",
        "dataclasses.asdict",
        "pathlib.Path"
      ],
      "classes": [
        {
          "name": "FunctionInfo",
          "docstring": "",
          "methods": [],
          "base_classes": []
        },
        {
          "name": "ClassInfo",
          "docstring": "",
          "methods": [],
          "base_classes": []
        },
        {
          "name": "FileInfo",
          "docstring": "",
          "methods": [],
          "base_classes": []
        },
        {
          "name": "ProjectAnalyzer",
          "docstring": "",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "project_path"
              ]
            },
            {
              "name": "analyze_project",
              "docstring": "",
              "args": [
                "self"
              ]
            },
            {
              "name": "analyze_file",
              "docstring": "",
              "args": [
                "self",
                "file_path"
              ]
            },
            {
              "name": "_extract_function_info",
              "docstring": "",
              "args": [
                "self",
                "node"
              ]
            },
            {
              "name": "_extract_class_info",
              "docstring": "",
              "args": [
                "self",
                "node"
              ]
            },
            {
              "name": "generate_summary",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [
        {
          "name": "format_for_chat",
          "docstring": "",
          "args": [
            "summary"
          ]
        },
        {
          "name": "analyze_project",
          "docstring": "",
          "args": [
            "project_path"
          ]
        }
      ],
      "global_variables": []
    },
    "setup.py": {
      "path": "setup.py",
      "imports": [
        "setuptools.setup",
        "setuptools.find_namespace_packages"
      ],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "tkinter_test.py": {
      "path": "tkinter_test.py",
      "imports": [
        "sys",
        "os",
        "logging"
      ],
      "classes": [],
      "functions": [
        {
          "name": "print_import_chain",
          "docstring": "Try to trace the import chain to identify circular import issues.",
          "args": []
        },
        {
          "name": "test_tkinter",
          "docstring": "",
          "args": []
        }
      ],
      "global_variables": [
        "project_root",
        "logger"
      ]
    },
    "__init__.py": {
      "path": "__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": [
        "__version__"
      ]
    },
    "alembic\\env.py": {
      "path": "alembic\\env.py",
      "imports": [
        "sys",
        "os",
        "pathlib.Path",
        "logging",
        "logging.config.fileConfig",
        "sqlalchemy.create_engine",
        "sqlalchemy.pool",
        "alembic.context",
        "database.sqlalchemy.models.Base"
      ],
      "classes": [],
      "functions": [
        {
          "name": "run_migrations_offline",
          "docstring": "Run migrations in 'offline' mode.",
          "args": []
        },
        {
          "name": "run_migrations_online",
          "docstring": "Run migrations in 'online' mode.",
          "args": []
        }
      ],
      "global_variables": [
        "project_root",
        "config",
        "target_metadata"
      ]
    },
    "config\\application_config.py": {
      "path": "config\\application_config.py",
      "imports": [
        "os",
        "pathlib.Path",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "json"
      ],
      "classes": [
        {
          "name": "ApplicationConfig",
          "docstring": "Centralized application configuration",
          "methods": [
            {
              "name": "__new__",
              "docstring": "Singleton pattern to ensure only one configuration instance",
              "args": [
                "cls"
              ]
            },
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self"
              ]
            },
            {
              "name": "_load_config",
              "docstring": "Load configuration from file and environment variables",
              "args": [
                "self"
              ]
            },
            {
              "name": "_get_config_dir",
              "docstring": "Get the configuration directory",
              "args": [
                "self"
              ]
            },
            {
              "name": "_get_config_path",
              "docstring": "Get the path to the configuration file",
              "args": [
                "self"
              ]
            },
            {
              "name": "_merge_config",
              "docstring": "Recursively merge configuration dictionaries",
              "args": [
                "self",
                "config"
              ]
            },
            {
              "name": "_load_from_env",
              "docstring": "Load configuration from environment variables",
              "args": [
                "self"
              ]
            },
            {
              "name": "get",
              "docstring": "Get a configuration value by key path",
              "args": [
                "self"
              ]
            },
            {
              "name": "set",
              "docstring": "Set a configuration value by key path",
              "args": [
                "self",
                "value"
              ]
            },
            {
              "name": "save",
              "docstring": "Save configuration to file",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "config\\environment.py": {
      "path": "config\\environment.py",
      "imports": [
        "os",
        "pathlib.Path",
        "dotenv.load_dotenv"
      ],
      "classes": [
        {
          "name": "EnvironmentManager",
          "docstring": "Centralized environment configuration management",
          "methods": [
            {
              "name": "__new__",
              "docstring": "",
              "args": [
                "cls"
              ]
            },
            {
              "name": "_initialize",
              "docstring": "",
              "args": [
                "self"
              ]
            },
            {
              "name": "get",
              "docstring": "Retrieve environment variable with optional default",
              "args": [
                "key",
                "default"
              ]
            },
            {
              "name": "is_debug",
              "docstring": "Check if application is in debug mode",
              "args": []
            },
            {
              "name": "get_log_level",
              "docstring": "Get configured log level",
              "args": []
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": [
        "env"
      ]
    },
    "config\\settings.py": {
      "path": "config\\settings.py",
      "imports": [
        "os",
        "pathlib.Path"
      ],
      "classes": [],
      "functions": [
        {
          "name": "get_database_path",
          "docstring": "Returns the absolute path to the database file.\n\nReturns:\n    Path: The absolute path to the database file.",
          "args": []
        }
      ],
      "global_variables": [
        "APP_NAME",
        "APP_VERSION",
        "WINDOW_SIZE",
        "PROJECT_ROOT",
        "CONFIG_DIR",
        "DATABASE_FILENAME",
        "_DATABASE_PATH",
        "BACKUP_DIR",
        "LOG_DIR",
        "TABLES",
        "COLORS",
        "DEFAULT_PADDING",
        "MINIMUM_COLUMN_WIDTH",
        "DEFAULT_FONT",
        "HEADER_FONT"
      ]
    },
    "config\\__init__.py": {
      "path": "config\\__init__.py",
      "imports": [
        "settings.APP_NAME",
        "settings.APP_VERSION",
        "settings.WINDOW_SIZE",
        "settings.CONFIG_DIR",
        "settings.DATABASE_FILENAME",
        "settings.TABLES",
        "settings.COLORS",
        "settings.DEFAULT_PADDING",
        "settings.MINIMUM_COLUMN_WIDTH",
        "settings.DEFAULT_FONT",
        "settings.HEADER_FONT",
        "settings.BACKUP_DIR",
        "settings.LOG_DIR",
        "settings.get_database_path"
      ],
      "classes": [],
      "functions": [],
      "global_variables": [
        "__all__"
      ]
    },
    "database\\base.py": {
      "path": "database\\base.py",
      "imports": [
        "sqlalchemy.ext.declarative.declarative_base",
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.DateTime",
        "datetime.datetime"
      ],
      "classes": [
        {
          "name": "BaseModel",
          "docstring": "Abstract base model providing common fields and behaviors.\n\nAutomatically adds:\n- Primary key (id)\n- Creation timestamp\n- Last update timestamp",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "Default string representation of the model.\n\nReturns:\n    String representation with class name and ID",
              "args": [
                "self"
              ]
            },
            {
              "name": "to_dict",
              "docstring": "Convert model instance to dictionary.\n\nReturns:\n    Dictionary representation of the model",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        }
      ],
      "functions": [],
      "global_variables": [
        "Base"
      ]
    },
    "database\\config.py": {
      "path": "database\\config.py",
      "imports": [
        "os",
        "typing",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "pathlib.Path"
      ],
      "classes": [],
      "functions": [
        {
          "name": "get_database_url",
          "docstring": "Generate database connection URL with multiple configuration sources.\n\nPriority:\n1. Explicitly passed configuration\n2. Environment variables\n3. Default configuration\n\nArgs:\n    config: Optional configuration dictionary\n\nReturns:\n    Database connection URL",
          "args": [
            "config"
          ]
        },
        {
          "name": "_find_project_root",
          "docstring": "Dynamically find the project root directory.\n\nReturns:\n    Path to the project root",
          "args": []
        },
        {
          "name": "get_database_config",
          "docstring": "Retrieve comprehensive database configuration.\n\nCombines configuration from multiple sources.\n\nReturns:\n    Dictionary with database configuration",
          "args": []
        }
      ],
      "global_variables": [
        "database_manager"
      ]
    },
    "database\\initialize.py": {
      "path": "database\\initialize.py",
      "imports": [
        "logging",
        "sqlalchemy.create_engine",
        "sqlalchemy.orm.sessionmaker",
        "sqlalchemy.base.Base",
        "sqlalchemy.models.storage.Storage",
        "config.settings.get_database_path"
      ],
      "classes": [],
      "functions": [
        {
          "name": "initialize_database",
          "docstring": "Initialize the database, creating or resetting tables.\n\nArgs:\n    drop_existing (bool): Whether to drop existing tables before creation",
          "args": [
            "drop_existing"
          ]
        },
        {
          "name": "add_initial_data",
          "docstring": "Add initial default data to the database.\n\nArgs:\n    engine: SQLAlchemy engine (optional)",
          "args": [
            "engine"
          ]
        }
      ],
      "global_variables": [
        "logger"
      ]
    },
    "database\\session.py": {
      "path": "database\\session.py",
      "imports": [
        "os",
        "logging",
        "typing.Optional",
        "sqlalchemy",
        "sqlalchemy.create_engine",
        "sqlalchemy.orm.sessionmaker",
        "sqlalchemy.orm.scoped_session",
        "sqlalchemy_utils.database_exists",
        "sqlalchemy_utils.create_database",
        "config.settings.get_database_path",
        "utils.error_handling.DatabaseError"
      ],
      "classes": [],
      "functions": [
        {
          "name": "init_database",
          "docstring": "Initialize the database, creating it if it doesn't exist.\n\nArgs:\n    db_url: Optional database URL (uses default if not provided)\n\nRaises:\n    DatabaseError: If database initialization fails",
          "args": [
            "db_url"
          ]
        },
        {
          "name": "get_db_session",
          "docstring": "Provide a database session.\n\nYields:\n    SQLAlchemy session object\n\nRaises:\n    DatabaseError: If session creation fails",
          "args": []
        },
        {
          "name": "close_db_session",
          "docstring": "Close all database sessions.",
          "args": []
        }
      ],
      "global_variables": [
        "logger",
        "engine",
        "SessionLocal"
      ]
    },
    "database\\__init__.py": {
      "path": "database\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "di\\config.py": {
      "path": "di\\config.py",
      "imports": [
        "typing.Dict",
        "typing.Any",
        "typing.Type",
        "typing.TypeVar",
        "store_management.di.container.DependencyContainer",
        "store_management.database.sqlalchemy.session.get_db_session",
        "store_management.database.sqlalchemy.core.base_manager.BaseManager",
        "store_management.database.sqlalchemy.core.manager_factory.get_manager",
        "store_management.services.interfaces.storage_service.IStorageService",
        "store_management.services.implementations.storage_service.StorageService",
        "store_management.services.interfaces.order_service.IOrderService",
        "store_management.services.implementations.order_service.OrderService",
        "store_management.services.interfaces.recipe_service.IRecipeService",
        "store_management.services.implementations.recipe_service.RecipeService",
        "store_management.services.interfaces.shopping_list_service.IShoppingListService",
        "store_management.services.implementations.shopping_list_service.ShoppingListService",
        "store_management.services.interfaces.supplier_service.ISupplierService",
        "store_management.services.implementations.supplier_service.SupplierService",
        "store_management.database.sqlalchemy.core.specialized.storage_manager.StorageManager",
        "store_management.database.sqlalchemy.core.specialized.order_manager.OrderManager",
        "store_management.database.sqlalchemy.core.specialized.recipe_manager.RecipeManager",
        "store_management.database.sqlalchemy.core.specialized.shopping_list_manager.ShoppingListManager",
        "store_management.database.sqlalchemy.core.specialized.supplier_manager.SupplierManager"
      ],
      "classes": [
        {
          "name": "ApplicationConfig",
          "docstring": "Dependency Injection Configuration for the Store Management Application.\n\nResponsible for:\n- Configuring the dependency injection container\n- Registering services and their dependencies\n- Providing a centralized configuration mechanism",
          "methods": [
            {
              "name": "configure_container",
              "docstring": "Configure the dependency injection container.\n\nThis method sets up the entire dependency graph for the application.\n\nReturns:\n    Configured DependencyContainer instance",
              "args": [
                "cls"
              ]
            },
            {
              "name": "_register_services",
              "docstring": "Register all application services in the dependency container.\n\nArgs:\n    container: Dependency container to register services in",
              "args": [
                "cls",
                "container"
              ]
            },
            {
              "name": "get_service",
              "docstring": "Retrieve a service from the dependency container.\n\nArgs:\n    container: Dependency container\n    service_type: Type of service to retrieve\n\nReturns:\n    Resolved service instance",
              "args": [
                "cls",
                "container",
                "service_type"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": [
        "T"
      ]
    },
    "di\\container.py": {
      "path": "di\\container.py",
      "imports": [
        "typing.Any",
        "typing.Type",
        "typing.Callable",
        "typing.Dict",
        "typing.Optional",
        "typing.TypeVar"
      ],
      "classes": [
        {
          "name": "DependencyContainer",
          "docstring": "Advanced dependency injection container with comprehensive capabilities.\n\nProvides:\n- Singleton and transient dependency registration\n- Lazy initialization\n- Type-safe dependency resolution\n- Circular dependency detection\n- Flexible dependency management",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the dependency container with empty registries.",
              "args": [
                "self"
              ]
            },
            {
              "name": "_get_type_key",
              "docstring": "Generate a unique string key for a given type.\n\nArgs:\n    type_: The type to generate a key for\n\nReturns:\n    A unique string representation of the type",
              "args": [
                "self",
                "type_"
              ]
            },
            {
              "name": "register",
              "docstring": "Register a dependency with advanced configuration options.\n\nArgs:\n    interface_type: The interface or base type to register\n    implementation_factory: Factory function to create the implementation\n    singleton: Whether to cache the instance (default: True)\n    dependencies: Optional dictionary of dependencies to inject\n\nRaises:\n    ValueError: If the dependency is already registered",
              "args": [
                "self",
                "interface_type",
                "implementation_factory",
                "singleton",
                "dependencies"
              ]
            },
            {
              "name": "resolve",
              "docstring": "Resolve a dependency with advanced resolution strategy.\n\nArgs:\n    interface_type: The type/interface to resolve\n\nReturns:\n    Instance of the requested dependency\n\nRaises:\n    ValueError: If dependency is not registered or circular dependency is detected",
              "args": [
                "self",
                "interface_type"
              ]
            },
            {
              "name": "get_service",
              "docstring": "Alias for resolve method to maintain compatibility.\n\nArgs:\n    interface_type: The type/interface to resolve\n\nReturns:\n    Instance of the requested dependency",
              "args": [
                "self",
                "interface_type"
              ]
            },
            {
              "name": "clear",
              "docstring": "Clear all registered dependencies, singleton instances, and resolving state.",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_all_registered_types",
              "docstring": "Retrieve all registered dependency types.\n\nReturns:\n    List of registered type keys",
              "args": [
                "self"
              ]
            },
            {
              "name": "is_registered",
              "docstring": "Check if a dependency is already registered.\n\nArgs:\n    interface_type: The type to check for registration\n\nReturns:\n    bool: True if the dependency is registered, False otherwise",
              "args": [
                "self",
                "interface_type"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": [
        "T"
      ]
    },
    "di\\service.py": {
      "path": "di\\service.py",
      "imports": [
        "abc",
        "typing.TypeVar",
        "typing.Type",
        "typing.Generic",
        "typing.Any",
        "store_management.di.container.DependencyContainer"
      ],
      "classes": [
        {
          "name": "Service",
          "docstring": "Base class for services that use dependency injection.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the service with a dependency container.\n\nArgs:\n    container: Dependency injection container",
              "args": [
                "self",
                "container"
              ]
            },
            {
              "name": "get_dependency",
              "docstring": "Get a dependency from the container.\n\nArgs:\n    dependency_type: Type of dependency to retrieve\n\nReturns:\n    Instance of the requested dependency",
              "args": [
                "self",
                "dependency_type"
              ]
            }
          ],
          "base_classes": [
            "abc.ABC"
          ]
        }
      ],
      "functions": [],
      "global_variables": [
        "T"
      ]
    },
    "di\\__init__.py": {
      "path": "di\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "gui\\base_view.py": {
      "path": "gui\\base_view.py",
      "imports": [
        "tkinter",
        "tkinter.ttk",
        "tkinter.messagebox",
        "typing.Any",
        "typing.Optional",
        "typing.Type",
        "store_management.application.Application",
        "store_management.services.interfaces.base_service.IBaseService"
      ],
      "classes": [
        {
          "name": "BaseView",
          "docstring": "Base class for all view components in the application.\n\nProvides common functionality for GUI views:\n- Service resolution\n- Basic error handling\n- Message dialogs\n- Lifecycle management methods\n\nAttributes:\n    _app (Application): Reference to the main application instance\n    _parent (tk.Widget): Parent widget for this view",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the base view.\n\nArgs:\n    parent: Parent widget\n    app: Main application instance",
              "args": [
                "self",
                "parent",
                "app"
              ]
            },
            {
              "name": "get_service",
              "docstring": "Retrieve a service from the application's dependency container.\n\nArgs:\n    service_type: Type of service to retrieve\n\nReturns:\n    Resolved service instance\n\nRaises:\n    ValueError: If service cannot be resolved",
              "args": [
                "self",
                "service_type"
              ]
            },
            {
              "name": "load_data",
              "docstring": "Load initial data for the view.\n\nSubclasses should override this method to implement\ndata loading logic specific to the view.",
              "args": [
                "self"
              ]
            },
            {
              "name": "save",
              "docstring": "Save current view data.\n\nSubclasses should override this method to implement\ndata saving logic specific to the view.",
              "args": [
                "self"
              ]
            },
            {
              "name": "undo",
              "docstring": "Undo the last action in the view.\n\nSubclasses should override this method to implement\nundo functionality specific to the view.",
              "args": [
                "self"
              ]
            },
            {
              "name": "redo",
              "docstring": "Redo the last undone action in the view.\n\nSubclasses should override this method to implement\nredo functionality specific to the view.",
              "args": [
                "self"
              ]
            },
            {
              "name": "show_error",
              "docstring": "Display an error message dialog.\n\nArgs:\n    title: Title of the error dialog\n    message: Error message to display",
              "args": [
                "self",
                "title",
                "message"
              ]
            },
            {
              "name": "show_info",
              "docstring": "Display an information message dialog.\n\nArgs:\n    title: Title of the info dialog\n    message: Information message to display",
              "args": [
                "self",
                "title",
                "message"
              ]
            },
            {
              "name": "show_warning",
              "docstring": "Display a warning message dialog.\n\nArgs:\n    title: Title of the warning dialog\n    message: Warning message to display",
              "args": [
                "self",
                "title",
                "message"
              ]
            },
            {
              "name": "confirm",
              "docstring": "Show a confirmation dialog with Yes/No options.\n\nArgs:\n    title: Title of the confirmation dialog\n    message: Confirmation message to display\n\nReturns:\n    True if user clicks Yes, False otherwise",
              "args": [
                "self",
                "title",
                "message"
              ]
            },
            {
              "name": "set_status",
              "docstring": "Set status message in the main window.\n\nArgs:\n    message: Status message to display",
              "args": [
                "self",
                "message"
              ]
            }
          ],
          "base_classes": [
            "ttk.Frame"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "gui\\main_window.py": {
      "path": "gui\\main_window.py",
      "imports": [
        "tkinter",
        "tkinter.ttk",
        "sys",
        "os",
        "store_management.application.Application",
        "store_management.gui.order.order_view.OrderView",
        "store_management.gui.storage.storage_view.StorageView",
        "store_management.gui.recipe.recipe_view.RecipeView",
        "store_management.gui.shopping_list.shopping_list_view.ShoppingListView",
        "store_management.services.interfaces.storage_service.IStorageService",
        "store_management.services.interfaces.order_service.IOrderService",
        "store_management.services.interfaces.inventory_service.IInventoryService",
        "store_management.services.interfaces.recipe_service.IRecipeService",
        "store_management.services.interfaces.shopping_list_service.IShoppingListService"
      ],
      "classes": [
        {
          "name": "MainWindow",
          "docstring": "Main application window managing the core GUI structure.\n\nResponsibilities:\n- Create main application window\n- Manage application tabs\n- Handle global application-level interactions\n- Provide status bar and menu functionality",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the main application window.\n\nArgs:\n    root: Tkinter root window\n    app: Application instance for dependency management",
              "args": [
                "self",
                "root",
                "app"
              ]
            },
            {
              "name": "_create_menu",
              "docstring": "Create the main menu bar with application-wide options.",
              "args": [
                "self"
              ]
            },
            {
              "name": "_create_main_notebook",
              "docstring": "Create a notebook (tabbed) interface for different views.",
              "args": [
                "self"
              ]
            },
            {
              "name": "_create_status_bar",
              "docstring": "Create a status bar at the bottom of the application window.",
              "args": [
                "self"
              ]
            },
            {
              "name": "_bind_global_shortcuts",
              "docstring": "Bind global keyboard shortcuts for common actions.",
              "args": [
                "self"
              ]
            },
            {
              "name": "set_status",
              "docstring": "Update the status bar message.\n\nArgs:\n    message: Status message to display",
              "args": [
                "self",
                "message"
              ]
            },
            {
              "name": "_on_new",
              "docstring": "Handle 'New' menu action.",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "_on_open",
              "docstring": "Handle 'Open' menu action.",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "_on_save",
              "docstring": "Handle 'Save' menu action.\n\nArgs:\n    event: Optional tkinter event (for keyboard shortcut)",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "_on_undo",
              "docstring": "Handle 'Undo' menu action.\n\nArgs:\n    event: Optional tkinter event (for keyboard shortcut)",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "_on_redo",
              "docstring": "Handle 'Redo' menu action.\n\nArgs:\n    event: Optional tkinter event (for keyboard shortcut)",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "_get_current_view",
              "docstring": "Get the currently selected view in the notebook.\n\nReturns:\n    Currently selected view or None",
              "args": [
                "self"
              ]
            },
            {
              "name": "_on_exit",
              "docstring": "Handle application exit.\nPerforms cleanup and closes the application.",
              "args": [
                "self"
              ]
            },
            {
              "name": "run",
              "docstring": "Start the main application event loop.",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "gui\\__init__.py": {
      "path": "gui\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "modules\\__init__.py": {
      "path": "modules\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "services\\inventory_service.py": {
      "path": "services\\inventory_service.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Tuple",
        "datetime.datetime",
        "store_management.database.sqlalchemy.models.Part.Part",
        "store_management.database.sqlalchemy.models.Leather.Leather",
        "store_management.database.sqlalchemy.models.InventoryStatus.InventoryStatus",
        "store_management.database.sqlalchemy.models.TransactionType.TransactionType",
        "store_management.database.sqlalchemy.models.InventoryTransaction.InventoryTransaction",
        "store_management.database.sqlalchemy.core.manager_factory.get_manager"
      ],
      "classes": [
        {
          "name": "InventoryService",
          "docstring": "Service for inventory management operations.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize service with appropriate managers.",
              "args": [
                "self"
              ]
            },
            {
              "name": "update_part_stock",
              "docstring": "Update part stock with transaction tracking.\n\nArgs:\n    part_id: Part ID\n    quantity_change: Change in quantity (positive or negative)\n    transaction_type: Type of transaction\n    notes: Optional notes\n\nReturns:\n    Tuple of (success, message)",
              "args": [
                "self",
                "part_id",
                "quantity_change",
                "transaction_type",
                "notes"
              ]
            },
            {
              "name": "update_leather_area",
              "docstring": "Update leather area with transaction tracking.\n\nArgs:\n    leather_id: Leather ID\n    area_change: Change in area (positive or negative)\n    transaction_type: Type of transaction\n    notes: Optional notes\n    wastage: Optional wastage area\n\nReturns:\n    Tuple of (success, message)",
              "args": [
                "self",
                "leather_id",
                "area_change",
                "transaction_type",
                "notes",
                "wastage"
              ]
            },
            {
              "name": "get_low_stock_parts",
              "docstring": "Get parts with low stock levels.\n\nArgs:\n    include_out_of_stock: Whether to include out of stock items\n\nReturns:\n    List of parts with low stock",
              "args": [
                "self",
                "include_out_of_stock"
              ]
            },
            {
              "name": "get_low_stock_leather",
              "docstring": "Get leather with low stock levels.\n\nArgs:\n    include_out_of_stock: Whether to include out of stock items\n\nReturns:\n    List of leather with low stock",
              "args": [
                "self",
                "include_out_of_stock"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "services\\order_service.py": {
      "path": "services\\order_service.py",
      "imports": [
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "typing.Tuple",
        "datetime.datetime",
        "store_management.database.sqlalchemy.models.order.Order",
        "store_management.database.sqlalchemy.models.order.OrderItem",
        "store_management.database.sqlalchemy.models.supplier.Supplier",
        "store_management.database.sqlalchemy.models.part.Part",
        "store_management.database.sqlalchemy.models.leather.Leather",
        "store_management.database.sqlalchemy.models.enums.OrderStatus",
        "store_management.database.sqlalchemy.models.enums.PaymentStatus",
        "store_management.database.sqlalchemy.manager_factory.get_manager"
      ],
      "classes": [
        {
          "name": "OrderService",
          "docstring": "Service for order management operations",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize with appropriate managers",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_order",
              "docstring": "Create a new order with items.\n\nArgs:\n    order_data: Dictionary with order data\n    items: List of dictionaries with item data\n\nReturns:\n    Tuple of (created order or None, result message)",
              "args": [
                "self",
                "order_data",
                "items"
              ]
            },
            {
              "name": "update_order_status",
              "docstring": "Update order status with validation of status transitions.\n\nArgs:\n    order_id: Order ID\n    status: New status\n\nReturns:\n    Tuple of (success, message)",
              "args": [
                "self",
                "order_id",
                "status"
              ]
            },
            {
              "name": "_is_valid_status_transition",
              "docstring": "Validate if a status transition is allowed.\n\nArgs:\n    current_status: Current order status\n    new_status: New order status\n\nReturns:\n    True if transition is valid, False otherwise",
              "args": [
                "self",
                "current_status",
                "new_status"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "services\\recipe_service.py": {
      "path": "services\\recipe_service.py",
      "imports": [
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "typing.Tuple",
        "store_management.database.sqlalchemy.models.recipe.Recipe",
        "store_management.database.sqlalchemy.models.recipe.RecipeItem",
        "store_management.database.sqlalchemy.models.part.Part",
        "store_management.database.sqlalchemy.models.leather.Leather",
        "store_management.database.sqlalchemy.manager_factory.get_manager"
      ],
      "classes": [
        {
          "name": "RecipeService",
          "docstring": "Service for recipe management operations",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize with appropriate managers",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_recipe",
              "docstring": "Create a new recipe with items.\n\nArgs:\n    recipe_data: Dictionary with recipe data\n    items: List of dictionaries with item data\n\nReturns:\n    Tuple of (created recipe or None, result message)",
              "args": [
                "self",
                "recipe_data",
                "items"
              ]
            },
            {
              "name": "check_materials_availability",
              "docstring": "Check if materials for a recipe are available in sufficient quantity.\n\nArgs:\n    recipe_id: Recipe ID\n    quantity: Number of items to produce\n\nReturns:\n    Tuple of (all materials available, list of missing items)",
              "args": [
                "self",
                "recipe_id",
                "quantity"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "services\\shopping_list_service.py": {
      "path": "services\\shopping_list_service.py",
      "imports": [
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "typing.Tuple",
        "datetime.datetime",
        "store_management.database.sqlalchemy.models.shopping_list.ShoppingList",
        "store_management.database.sqlalchemy.models.shopping_list.ShoppingListItem",
        "store_management.database.sqlalchemy.models.part.Part",
        "store_management.database.sqlalchemy.models.leather.Leather",
        "store_management.database.sqlalchemy.manager_factory.get_manager"
      ],
      "classes": [
        {
          "name": "ShoppingListService",
          "docstring": "Service for shopping list management operations",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize with appropriate managers",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_shopping_list",
              "docstring": "Create a new shopping list with optional items.\n\nArgs:\n    list_data: Shopping list data\n    items: Optional list of item data\n\nReturns:\n    Tuple of (created shopping list or None, result message)",
              "args": [
                "self",
                "list_data",
                "items"
              ]
            },
            {
              "name": "add_item_to_list",
              "docstring": "Add an item to a shopping list.\n\nArgs:\n    list_id: Shopping list ID\n    item_data: Item data\n\nReturns:\n    Tuple of (created item or None, result message)",
              "args": [
                "self",
                "list_id",
                "item_data"
              ]
            },
            {
              "name": "mark_item_purchased",
              "docstring": "Mark a shopping list item as purchased with purchase details.\n\nArgs:\n    item_id: Shopping list item ID\n    purchase_data: Purchase details (date, price)\n\nReturns:\n    Tuple of (success, message)",
              "args": [
                "self",
                "item_id",
                "purchase_data"
              ]
            },
            {
              "name": "get_pending_items_by_supplier",
              "docstring": "Get pending items grouped by supplier.\n\nReturns:\n    Dictionary mapping supplier IDs to lists of pending items",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "services\\storage_service.py": {
      "path": "services\\storage_service.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "store_management.database.sqlalchemy.models.Storage",
        "store_management.database.sqlalchemy.models.Product",
        "store_management.services.interfaces.storage_service.IStorageService"
      ],
      "classes": [
        {
          "name": "StorageService",
          "docstring": "Service for managing storage locations.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize StorageService with a database manager.\n\nArgs:\n    db_manager: Database manager for storage operations",
              "args": [
                "self",
                "db_manager"
              ]
            },
            {
              "name": "get_all_storage_locations",
              "docstring": "Retrieve all storage locations.\n\nReturns:\n    List of storage location dictionaries",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_storage_by_id",
              "docstring": "Retrieve a specific storage location by ID.\n\nArgs:\n    storage_id: ID of the storage location\n\nReturns:\n    Storage location details or None if not found",
              "args": [
                "self",
                "storage_id"
              ]
            },
            {
              "name": "_to_dict",
              "docstring": "Convert a Storage model to a dictionary.\n\nArgs:\n    storage: Storage model instance\n\nReturns:\n    Dictionary representation of the storage location",
              "args": [
                "self",
                "storage"
              ]
            },
            {
              "name": "_product_to_dict",
              "docstring": "Convert a Product model to a dictionary.\n\nArgs:\n    product: Product model instance\n\nReturns:\n    Dictionary representation of the product",
              "args": [
                "self",
                "product"
              ]
            }
          ],
          "base_classes": [
            "IStorageService"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "services\\__init__.py": {
      "path": "services\\__init__.py",
      "imports": [
        "implementations.storage_service.StorageService",
        "interfaces.storage_service.IStorageService"
      ],
      "classes": [],
      "functions": [],
      "global_variables": [
        "__all__"
      ]
    },
    "src\\database_init.py": {
      "path": "src\\database_init.py",
      "imports": [
        "sqlite3",
        "pathlib.Path"
      ],
      "classes": [],
      "functions": [
        {
          "name": "init_database",
          "docstring": "",
          "args": []
        }
      ],
      "global_variables": []
    },
    "src\\__init__.py": {
      "path": "src\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "tests\\test_storage.py": {
      "path": "tests\\test_storage.py",
      "imports": [
        "store_management.database.sqlalchemy.managers.storage_manager.StorageManager"
      ],
      "classes": [],
      "functions": [
        {
          "name": "test_storage_operations",
          "docstring": "",
          "args": []
        }
      ],
      "global_variables": []
    },
    "tests\\__init__.py": {
      "path": "tests\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "tools\\run_migration.py": {
      "path": "tools\\run_migration.py",
      "imports": [
        "argparse",
        "logging",
        "sys",
        "pathlib.Path",
        "sqlalchemy.create_engine",
        "sqlalchemy.orm.sessionmaker",
        "store_management.database.models.base.Base",
        "store_management.config.application_config.ApplicationConfig"
      ],
      "classes": [],
      "functions": [
        {
          "name": "setup_logging",
          "docstring": "Configure logging for migrations",
          "args": []
        },
        {
          "name": "run_migrations",
          "docstring": "Run database migrations",
          "args": [
            "db_url",
            "drop_existing"
          ]
        },
        {
          "name": "main",
          "docstring": "Main entry point",
          "args": []
        }
      ],
      "global_variables": []
    },
    "tools\\__init__.py": {
      "path": "tools\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "utils\\backup.py": {
      "path": "utils\\backup.py",
      "imports": [
        "sqlite3",
        "os",
        "shutil",
        "json",
        "datetime.datetime",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "pathlib.Path",
        "datetime.datetime",
        "typing.Optional"
      ],
      "classes": [
        {
          "name": "DatabaseBackup",
          "docstring": "Handler for database backups",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "db_path"
              ]
            },
            {
              "name": "create_backup",
              "docstring": "Create a backup before performing an operation",
              "args": [
                "self",
                "operation"
              ]
            },
            {
              "name": "restore_backup",
              "docstring": "Restore database from backup",
              "args": [
                "self",
                "backup_path"
              ]
            },
            {
              "name": "list_backups",
              "docstring": "List available backups with metadata",
              "args": [
                "self"
              ]
            },
            {
              "name": "cleanup_old_backups",
              "docstring": "Clean up backups older than specified days",
              "args": [
                "self",
                "keep_days"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "utils\\database_utilities.py": {
      "path": "utils\\database_utilities.py",
      "imports": [
        "sqlite3",
        "json",
        "csv",
        "datetime",
        "pathlib.Path",
        "typing.Dict",
        "typing.List",
        "typing.Any",
        "zipfile",
        "io"
      ],
      "classes": [
        {
          "name": "DatabaseUtilities",
          "docstring": "",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "db_path"
              ]
            },
            {
              "name": "export_database",
              "docstring": "Export database to a zip file containing JSON and CSV formats",
              "args": [
                "self",
                "export_path"
              ]
            },
            {
              "name": "import_database",
              "docstring": "Import database from a zip file",
              "args": [
                "self",
                "import_path"
              ]
            },
            {
              "name": "export_schema",
              "docstring": "Export database schema",
              "args": [
                "self"
              ]
            },
            {
              "name": "optimize_database",
              "docstring": "Optimize database (vacuum, analyze, etc.)",
              "args": [
                "self"
              ]
            },
            {
              "name": "verify_database",
              "docstring": "Verify database integrity and return status report",
              "args": [
                "self"
              ]
            },
            {
              "name": "generate_report",
              "docstring": "Generate various types of reports",
              "args": [
                "self",
                "report_type"
              ]
            },
            {
              "name": "_generate_inventory_report",
              "docstring": "Generate inventory report",
              "args": [
                "self",
                "cursor"
              ]
            },
            {
              "name": "_generate_orders_report",
              "docstring": "Generate orders report",
              "args": [
                "self",
                "cursor"
              ]
            },
            {
              "name": "_generate_suppliers_report",
              "docstring": "Generate suppliers report",
              "args": [
                "self",
                "cursor"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "utils\\error_handler.py": {
      "path": "utils\\error_handler.py",
      "imports": [
        "tkinter",
        "tkinter.messagebox",
        "functools",
        "functools.wraps",
        "store_management.utils.logger.log_error",
        "store_management.utils.logger.logger",
        "traceback"
      ],
      "classes": [
        {
          "name": "ErrorHandler",
          "docstring": "    ",
          "methods": [
            {
              "name": "log_database_action",
              "docstring": "Log database-related actions",
              "args": [
                "action",
                "details"
              ]
            },
            {
              "name": "validate_positive_integer",
              "docstring": "Validate that a value is a positive integer",
              "args": [
                "value",
                "field_name"
              ]
            },
            {
              "name": "show_error",
              "docstring": "Show error message to user and log it",
              "args": [
                "self",
                "title",
                "message",
                "error"
              ]
            },
            {
              "name": "show_warning",
              "docstring": "Show warning message to user and log it",
              "args": [
                "self",
                "title",
                "message"
              ]
            },
            {
              "name": "handle_error",
              "docstring": "Decorator for handling errors in functions",
              "args": [
                "self",
                "func"
              ]
            }
          ],
          "base_classes": []
        },
        {
          "name": "ApplicationError",
          "docstring": "Base class for application-specific errors",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "message",
                "details"
              ]
            }
          ],
          "base_classes": [
            "Exception"
          ]
        },
        {
          "name": "DatabaseError",
          "docstring": "Error raised for database-related issues",
          "methods": [],
          "base_classes": [
            "ApplicationError"
          ]
        },
        {
          "name": "ValidationError",
          "docstring": "Error raised for data validation issues",
          "methods": [],
          "base_classes": [
            "ApplicationError"
          ]
        }
      ],
      "functions": [
        {
          "name": "check_database_connection",
          "docstring": "Decorator to check database connection before executing database operations",
          "args": [
            "func"
          ]
        },
        {
          "name": "get_error_context",
          "docstring": "Get current error context including stack trace",
          "args": []
        }
      ],
      "global_variables": []
    },
    "utils\\error_handling.py": {
      "path": "utils\\error_handling.py",
      "imports": [
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "traceback",
        "logging"
      ],
      "classes": [
        {
          "name": "DatabaseError",
          "docstring": "Custom exception for database-related errors.\n\nProvides detailed context about database operation failures.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize a database error with detailed information.\n\nArgs:\n    message: Primary error message\n    details: Additional error details or stack trace\n    error_code: Optional error code for identification",
              "args": [
                "self",
                "message",
                "details",
                "error_code"
              ]
            },
            {
              "name": "__str__",
              "docstring": "Provide a comprehensive string representation of the error.\n\nReturns:\n    Formatted error message with details",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Exception"
          ]
        }
      ],
      "functions": [
        {
          "name": "handle_database_error",
          "docstring": "Standardized handler for database-related errors.\n\nArgs:\n    operation: Description of the operation that failed\n    error: The original exception\n    context: Optional context dictionary with additional information\n\nReturns:\n    A standardized DatabaseError instance",
          "args": [
            "operation",
            "error",
            "context"
          ]
        },
        {
          "name": "log_database_action",
          "docstring": "Log database-related actions with optional details.\n\nArgs:\n    action: Description of the database action\n    details: Optional dictionary of additional details\n    level: Logging level (info, warning, error)",
          "args": [
            "action",
            "details",
            "level"
          ]
        }
      ],
      "global_variables": []
    },
    "utils\\exporters.py": {
      "path": "utils\\exporters.py",
      "imports": [
        "csv",
        "json",
        "xlsxwriter",
        "typing.Dict",
        "typing.List",
        "typing.Any",
        "typing.Optional",
        "pathlib.Path",
        "datetime.datetime",
        "pandas"
      ],
      "classes": [
        {
          "name": "OrderExporter",
          "docstring": "Handler for exporting order data",
          "methods": [
            {
              "name": "export_to_csv",
              "docstring": "Export order data to CSV",
              "args": [
                "data",
                "filepath"
              ]
            },
            {
              "name": "export_to_excel",
              "docstring": "Export order data to Excel",
              "args": [
                "data",
                "filepath"
              ]
            },
            {
              "name": "export_to_json",
              "docstring": "Export order data to JSON (backup)",
              "args": [
                "data",
                "filepath"
              ]
            }
          ],
          "base_classes": []
        },
        {
          "name": "OrderImporter",
          "docstring": "Handler for importing order data",
          "methods": [
            {
              "name": "import_from_csv",
              "docstring": "Import order data from CSV files",
              "args": [
                "order_file",
                "details_file"
              ]
            },
            {
              "name": "import_from_excel",
              "docstring": "Import order data from Excel file",
              "args": [
                "filepath"
              ]
            },
            {
              "name": "import_from_json",
              "docstring": "Import order data from JSON backup",
              "args": [
                "filepath"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "utils\\logger.py": {
      "path": "utils\\logger.py",
      "imports": [
        "logging",
        "logging.handlers",
        "os",
        "pathlib.Path",
        "typing.Optional",
        "store_management.config.LOG_DIR"
      ],
      "classes": [
        {
          "name": "AppLogger",
          "docstring": "",
          "methods": [
            {
              "name": "__new__",
              "docstring": "",
              "args": [
                "cls"
              ]
            },
            {
              "name": "_initialize_logger",
              "docstring": "Initialize the application logger with file and console handlers.",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_logger",
              "docstring": "Get the configured logger instance.",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [
        {
          "name": "get_logger",
          "docstring": "Get a logger instance, optionally with a specific name.\n\nArgs:\n    name: Optional name for the logger. If provided, returns a child logger\n         of the main application logger.\n\nReturns:\n    logging.Logger: Configured logger instance",
          "args": [
            "name"
          ]
        },
        {
          "name": "log_error",
          "docstring": "Log an error with optional context information.\n\nArgs:\n    error: The exception to log\n    context: Optional dictionary with additional context",
          "args": [
            "error",
            "context"
          ]
        },
        {
          "name": "log_info",
          "docstring": "Log an info message.\n\nArgs:\n    message: The message to log",
          "args": [
            "message"
          ]
        },
        {
          "name": "log_debug",
          "docstring": "Log a debug message.\n\nArgs:\n    message: The message to log",
          "args": [
            "message"
          ]
        }
      ],
      "global_variables": [
        "logger_instance",
        "logger"
      ]
    },
    "utils\\logging_config.py": {
      "path": "utils\\logging_config.py",
      "imports": [
        "os",
        "sys",
        "logging",
        "logging.handlers.RotatingFileHandler",
        "traceback",
        "typing.Optional",
        "typing.Any",
        "typing.Dict"
      ],
      "classes": [
        {
          "name": "LoggerConfig",
          "docstring": "Comprehensive logging configuration with multiple handlers\nand advanced formatting",
          "methods": [
            {
              "name": "create_logger",
              "docstring": "Create a configured logger with file and console handlers\n\nArgs:\n    name (str): Logger name\n    log_level (str): Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n    log_dir (Optional[str]): Directory for log files\n\nReturns:\n    Configured logging.Logger instance",
              "args": [
                "name",
                "log_level",
                "log_dir"
              ]
            }
          ],
          "base_classes": []
        },
        {
          "name": "ErrorTracker",
          "docstring": "Advanced error tracking and logging utility",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize ErrorTracker\n\nArgs:\n    logger (Optional[logging.Logger]): Logger instance",
              "args": [
                "self",
                "logger"
              ]
            },
            {
              "name": "log_error",
              "docstring": "Comprehensive error logging with context and stack trace\n\nArgs:\n    error (Exception): The exception to log\n    context (Optional[Dict]): Additional context information\n    additional_info (Optional[str]): Extra descriptive information",
              "args": [
                "self",
                "error",
                "context",
                "additional_info"
              ]
            },
            {
              "name": "trace_method",
              "docstring": "Method decorator for tracing method calls and errors\n\nArgs:\n    method_name (str): Name of the method being traced",
              "args": [
                "self",
                "method_name"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": [
        "logger",
        "error_tracker"
      ]
    },
    "utils\\notifications.py": {
      "path": "utils\\notifications.py",
      "imports": [
        "tkinter",
        "tkinter.ttk",
        "typing.Optional",
        "typing.Callable",
        "time",
        "enum.Enum",
        "queue.Queue",
        "threading"
      ],
      "classes": [
        {
          "name": "NotificationType",
          "docstring": "",
          "methods": [],
          "base_classes": [
            "Enum"
          ]
        },
        {
          "name": "StatusNotification",
          "docstring": "Status notification manager",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "parent"
              ]
            },
            {
              "name": "setup_styles",
              "docstring": "Setup notification styles",
              "args": [
                "self"
              ]
            },
            {
              "name": "start_processor",
              "docstring": "Start notification processing thread",
              "args": [
                "self"
              ]
            },
            {
              "name": "_process_notifications",
              "docstring": "Process notifications from queue",
              "args": [
                "self"
              ]
            },
            {
              "name": "_show_notification",
              "docstring": "Show notification",
              "args": [
                "self",
                "notification"
              ]
            },
            {
              "name": "_clear_notification",
              "docstring": "Clear current notification",
              "args": [
                "self",
                "callback"
              ]
            },
            {
              "name": "show_info",
              "docstring": "Show info notification",
              "args": [
                "self",
                "message",
                "duration"
              ]
            },
            {
              "name": "show_success",
              "docstring": "Show success notification",
              "args": [
                "self",
                "message",
                "duration"
              ]
            },
            {
              "name": "show_warning",
              "docstring": "Show warning notification",
              "args": [
                "self",
                "message",
                "duration"
              ]
            },
            {
              "name": "show_error",
              "docstring": "Show error notification",
              "args": [
                "self",
                "message",
                "duration"
              ]
            },
            {
              "name": "show_progress",
              "docstring": "Show progress notification",
              "args": [
                "self",
                "message",
                "callback"
              ]
            },
            {
              "name": "clear",
              "docstring": "Clear current notification",
              "args": [
                "self"
              ]
            },
            {
              "name": "cleanup",
              "docstring": "Cleanup resources",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "utils\\utils.py": {
      "path": "utils\\utils.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "utils\\validators.py": {
      "path": "utils\\validators.py",
      "imports": [
        "typing.Dict",
        "typing.Any",
        "typing.Tuple",
        "typing.Optional",
        "datetime.datetime",
        "re"
      ],
      "classes": [
        {
          "name": "OrderValidator",
          "docstring": "Validator for order-related data",
          "methods": [
            {
              "name": "validate_order",
              "docstring": "Validate order data",
              "args": [
                "data"
              ]
            },
            {
              "name": "validate_order_details",
              "docstring": "Validate order details data",
              "args": [
                "data"
              ]
            }
          ],
          "base_classes": []
        },
        {
          "name": "DataSanitizer",
          "docstring": "Sanitizer for input data",
          "methods": [
            {
              "name": "sanitize_string",
              "docstring": "Sanitize string input",
              "args": [
                "value"
              ]
            },
            {
              "name": "sanitize_numeric",
              "docstring": "Sanitize numeric input",
              "args": [
                "value"
              ]
            },
            {
              "name": "sanitize_identifier",
              "docstring": "Sanitize database identifiers",
              "args": [
                "value"
              ]
            },
            {
              "name": "sanitize_order_data",
              "docstring": "Sanitize order data",
              "args": [
                "data"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "utils\\__init__.py": {
      "path": "utils\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "views\\__init__.py": {
      "path": "views\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "utils\\order_exporter\\order_exporter.py": {
      "path": "utils\\order_exporter\\order_exporter.py",
      "imports": [
        "pandas",
        "typing.Dict",
        "typing.Any",
        "pathlib.Path",
        "json"
      ],
      "classes": [
        {
          "name": "OrderExporter",
          "docstring": "",
          "methods": [
            {
              "name": "export_to_excel",
              "docstring": "Export order data to Excel",
              "args": [
                "data",
                "filepath"
              ]
            },
            {
              "name": "export_to_csv",
              "docstring": "Export order data to CSV",
              "args": [
                "data",
                "filepath"
              ]
            },
            {
              "name": "export_to_json",
              "docstring": "Export order data to JSON",
              "args": [
                "data",
                "filepath"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "utils\\order_exporter\\__init__.py": {
      "path": "utils\\order_exporter\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "utils\\validators\\order_validator.py": {
      "path": "utils\\validators\\order_validator.py",
      "imports": [
        "typing.Tuple",
        "typing.Dict",
        "typing.Any",
        "datetime.datetime"
      ],
      "classes": [
        {
          "name": "OrderValidator",
          "docstring": "",
          "methods": [
            {
              "name": "validate_order",
              "docstring": "Validate order data",
              "args": [
                "data"
              ]
            },
            {
              "name": "validate_order_detail",
              "docstring": "Validate order detail data",
              "args": [
                "data"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "utils\\validators\\__init__.py": {
      "path": "utils\\validators\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "tests\\test_database\\test_base_manager.py": {
      "path": "tests\\test_database\\test_base_manager.py",
      "imports": [
        "pytest",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "sqlalchemy.create_engine",
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.orm.sessionmaker",
        "sqlalchemy.orm.declarative_base",
        "sqlalchemy.exc.SQLAlchemyError",
        "store_management.database.sqlalchemy.base_manager.BaseManager",
        "store_management.database.sqlalchemy.manager_factory.get_manager",
        "store_management.database.sqlalchemy.manager_factory.register_specialized_manager",
        "store_management.database.sqlalchemy.manager_factory.clear_manager_cache",
        "store_management.utils.error_handling.DatabaseError"
      ],
      "classes": [
        {
          "name": "TestModel",
          "docstring": "Test model for BaseManager unit tests.",
          "methods": [],
          "base_classes": [
            "TestBase"
          ]
        },
        {
          "name": "TestSpecializedManager",
          "docstring": "Specialized test manager with additional method.",
          "methods": [
            {
              "name": "get_by_name",
              "docstring": "Retrieve models by name.\n\nArgs:\n    name: Name to search for\n\nReturns:\n    List of matching models",
              "args": [
                "self",
                "name"
              ]
            }
          ],
          "base_classes": []
        },
        {
          "name": "TestBaseManager",
          "docstring": "Comprehensive test suite for BaseManager.",
          "methods": [
            {
              "name": "test_create_single_record",
              "docstring": "Test creating a single record.",
              "args": [
                "self",
                "test_manager"
              ]
            },
            {
              "name": "test_get_record",
              "docstring": "Test retrieving a single record by ID.",
              "args": [
                "self",
                "test_manager"
              ]
            },
            {
              "name": "test_update_record",
              "docstring": "Test updating an existing record.",
              "args": [
                "self",
                "test_manager"
              ]
            },
            {
              "name": "test_delete_record",
              "docstring": "Test deleting a record.",
              "args": [
                "self",
                "test_manager"
              ]
            },
            {
              "name": "test_bulk_create",
              "docstring": "Test bulk creation of records.",
              "args": [
                "self",
                "test_manager"
              ]
            },
            {
              "name": "test_bulk_update",
              "docstring": "Test bulk updating of records.",
              "args": [
                "self",
                "test_manager"
              ]
            },
            {
              "name": "test_get_all",
              "docstring": "Test retrieving all records.",
              "args": [
                "self",
                "test_manager"
              ]
            },
            {
              "name": "test_search",
              "docstring": "Test search functionality.",
              "args": [
                "self",
                "test_manager"
              ]
            },
            {
              "name": "test_filter",
              "docstring": "Test complex filtering.",
              "args": [
                "self",
                "test_manager"
              ]
            },
            {
              "name": "test_exists",
              "docstring": "Test existence check.",
              "args": [
                "self",
                "test_manager"
              ]
            },
            {
              "name": "test_count",
              "docstring": "Test record counting.",
              "args": [
                "self",
                "test_manager"
              ]
            },
            {
              "name": "test_specialized_manager",
              "docstring": "Test specialized manager functionality.",
              "args": [
                "self",
                "session_factory"
              ]
            }
          ],
          "base_classes": []
        },
        {
          "name": "TestErrorHandling",
          "docstring": "Test error handling scenarios.",
          "methods": [
            {
              "name": "test_create_invalid_data",
              "docstring": "Test creating record with invalid data.",
              "args": [
                "self",
                "test_manager"
              ]
            },
            {
              "name": "test_update_non_existent_record",
              "docstring": "Test updating a non-existent record.",
              "args": [
                "self",
                "test_manager"
              ]
            },
            {
              "name": "test_delete_non_existent_record",
              "docstring": "Test deleting a non-existent record.",
              "args": [
                "self",
                "test_manager"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [
        {
          "name": "test_engine",
          "docstring": "Create an in-memory SQLite database for testing.",
          "args": []
        },
        {
          "name": "session_factory",
          "docstring": "Create a session factory for testing.",
          "args": [
            "test_engine"
          ]
        },
        {
          "name": "test_manager",
          "docstring": "Create a BaseManager instance for testing.",
          "args": [
            "session_factory"
          ]
        }
      ],
      "global_variables": [
        "TestBase"
      ]
    },
    "tests\\test_database\\test_manager_factory.py": {
      "path": "tests\\test_database\\test_manager_factory.py",
      "imports": [
        "pytest",
        "sqlalchemy.create_engine",
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.orm.declarative_base",
        "sqlalchemy.orm.sessionmaker",
        "store_management.database.sqlalchemy.base_manager.BaseManager",
        "store_management.database.sqlalchemy.manager_factory.get_manager",
        "store_management.database.sqlalchemy.manager_factory.register_specialized_manager",
        "store_management.database.sqlalchemy.manager_factory.clear_manager_cache"
      ],
      "classes": [
        {
          "name": "FactoryTestModel",
          "docstring": "Test model for manager factory tests.",
          "methods": [],
          "base_classes": [
            "FactoryTestBase"
          ]
        },
        {
          "name": "CustomTestManager",
          "docstring": "Specialized test manager with additional method.",
          "methods": [
            {
              "name": "custom_method",
              "docstring": "Custom method to test specialized manager functionality.\n\nReturns:\n    A test string",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": []
        },
        {
          "name": "TestManagerFactory",
          "docstring": "Comprehensive test suite for manager factory.",
          "methods": [
            {
              "name": "test_engine",
              "docstring": "Create an in-memory SQLite database for testing.",
              "args": [
                "self"
              ]
            },
            {
              "name": "session_factory",
              "docstring": "Create a session factory for testing.",
              "args": [
                "self",
                "test_engine"
              ]
            },
            {
              "name": "test_manager_cache",
              "docstring": "Test manager caching mechanism.",
              "args": [
                "self",
                "session_factory"
              ]
            },
            {
              "name": "test_specialized_manager_registration",
              "docstring": "Test registering and using a specialized manager.",
              "args": [
                "self",
                "session_factory"
              ]
            },
            {
              "name": "test_force_new_manager",
              "docstring": "Test creating a new manager instance bypassing cache.",
              "args": [
                "self",
                "session_factory"
              ]
            },
            {
              "name": "test_manager_with_mixins",
              "docstring": "Test creating a manager with additional mixins.",
              "args": [
                "self",
                "session_factory"
              ]
            },
            {
              "name": "test_invalid_mixin",
              "docstring": "Test handling of invalid mixins.",
              "args": [
                "self",
                "session_factory"
              ]
            }
          ],
          "base_classes": []
        },
        {
          "name": "TestManagerPerformance",
          "docstring": "Performance-oriented tests for manager operations.",
          "methods": [
            {
              "name": "large_dataset_manager",
              "docstring": "Create a manager with a large dataset.",
              "args": [
                "self",
                "session_factory"
              ]
            },
            {
              "name": "test_large_dataset_retrieval",
              "docstring": "Test performance of retrieving large datasets.",
              "args": [
                "self",
                "large_dataset_manager"
              ]
            },
            {
              "name": "test_large_dataset_filtering",
              "docstring": "Test filtering performance on large datasets.",
              "args": [
                "self",
                "large_dataset_manager"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": [
        "FactoryTestBase"
      ]
    },
    "tests\\test_database\\__init__.py": {
      "path": "tests\\test_database\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "tests\\test_repositories\\test_storage_repository.py": {
      "path": "tests\\test_repositories\\test_storage_repository.py",
      "imports": [
        "unittest",
        "sqlalchemy.create_engine",
        "sqlalchemy.orm.sessionmaker",
        "store_management.database.models.base.Base",
        "store_management.database.models.storage.Storage",
        "store_management.database.repositories.storage_repository.StorageRepository"
      ],
      "classes": [
        {
          "name": "TestStorageRepository",
          "docstring": "Test cases for StorageRepository",
          "methods": [
            {
              "name": "setUp",
              "docstring": "Set up test database and repository",
              "args": [
                "self"
              ]
            },
            {
              "name": "tearDown",
              "docstring": "Clean up resources",
              "args": [
                "self"
              ]
            },
            {
              "name": "test_get_all",
              "docstring": "Test getting all storage locations",
              "args": [
                "self"
              ]
            },
            {
              "name": "test_get_by_id",
              "docstring": "Test getting storage by ID",
              "args": [
                "self"
              ]
            },
            {
              "name": "test_get_by_location",
              "docstring": "Test getting storage by location",
              "args": [
                "self"
              ]
            },
            {
              "name": "test_create",
              "docstring": "Test creating a new storage location",
              "args": [
                "self"
              ]
            },
            {
              "name": "test_update",
              "docstring": "Test updating a storage location",
              "args": [
                "self"
              ]
            },
            {
              "name": "test_delete",
              "docstring": "Test deleting a storage location",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "unittest.TestCase"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "tests\\test_repositories\\test_storage_service.py": {
      "path": "tests\\test_repositories\\test_storage_service.py",
      "imports": [
        "unittest",
        "unittest.mock.MagicMock",
        "unittest.mock.patch",
        "sqlalchemy.orm.Session",
        "store_management.services.storage_service.StorageService",
        "store_management.database.repositories.storage_repository.StorageRepository",
        "store_management.database.repositories.product_repository.ProductRepository",
        "store_management.database.models.storage.Storage",
        "store_management.database.models.product.Product"
      ],
      "classes": [
        {
          "name": "TestStorageService",
          "docstring": "Test cases for StorageService",
          "methods": [
            {
              "name": "setUp",
              "docstring": "Set up test service with mock repositories",
              "args": [
                "self"
              ]
            },
            {
              "name": "tearDown",
              "docstring": "Clean up resources",
              "args": [
                "self"
              ]
            },
            {
              "name": "test_assign_product_to_storage",
              "docstring": "Test assigning a product to storage",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "unittest.TestCase"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "tests\\test_repositories\\__init__.py": {
      "path": "tests\\test_repositories\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "src\\models\\__init__.py": {
      "path": "src\\models\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "services\\implementations\\inventory_service.py": {
      "path": "services\\implementations\\inventory_service.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Tuple",
        "typing.Type",
        "typing.cast",
        "datetime.datetime",
        "store_management.di.service.Service",
        "store_management.di.container.DependencyContainer",
        "store_management.services.interfaces.inventory_service.IInventoryService",
        "store_management.database.sqlalchemy.base_manager.BaseManager",
        "store_management.database.sqlalchemy.models.part.Part",
        "store_management.database.sqlalchemy.models.leather.Leather",
        "store_management.database.sqlalchemy.models.enums.InventoryStatus",
        "store_management.database.sqlalchemy.models.enums.TransactionType"
      ],
      "classes": [
        {
          "name": "InventoryService",
          "docstring": "Service for inventory management operations.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize service with appropriate managers.",
              "args": [
                "self",
                "container"
              ]
            },
            {
              "name": "update_part_stock",
              "docstring": "Update part stock with transaction tracking.\n\nArgs:\n    part_id: Part ID\n    quantity_change: Change in quantity (positive or negative)\n    transaction_type: Type of transaction\n    notes: Optional notes\n\nReturns:\n    Tuple of (success, message)",
              "args": [
                "self",
                "part_id",
                "quantity_change",
                "transaction_type",
                "notes"
              ]
            },
            {
              "name": "update_leather_area",
              "docstring": "Update leather area with transaction tracking.\n\nArgs:\n    leather_id: Leather ID\n    area_change: Change in area (positive or negative)\n    transaction_type: Type of transaction\n    notes: Optional notes\n    wastage: Optional wastage area\n\nReturns:\n    Tuple of (success, message)",
              "args": [
                "self",
                "leather_id",
                "area_change",
                "transaction_type",
                "notes",
                "wastage"
              ]
            },
            {
              "name": "get_low_stock_parts",
              "docstring": "Get parts with low stock levels.\n\nArgs:\n    include_out_of_stock: Whether to include out of stock items\n\nReturns:\n    List of parts with low stock",
              "args": [
                "self",
                "include_out_of_stock"
              ]
            },
            {
              "name": "get_low_stock_leather",
              "docstring": "Get leather with low stock levels.\n\nArgs:\n    include_out_of_stock: Whether to include out of stock items\n\nReturns:\n    List of leather with low stock",
              "args": [
                "self",
                "include_out_of_stock"
              ]
            },
            {
              "name": "_part_to_dict",
              "docstring": "Convert Part model to dictionary.",
              "args": [
                "self",
                "part"
              ]
            },
            {
              "name": "_leather_to_dict",
              "docstring": "Convert Leather model to dictionary.",
              "args": [
                "self",
                "leather"
              ]
            }
          ],
          "base_classes": [
            "Service",
            "IInventoryService"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "services\\implementations\\order_service.py": {
      "path": "services\\implementations\\order_service.py",
      "imports": [
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "typing.Tuple",
        "store_management.di.service.Service",
        "store_management.di.container.DependencyContainer",
        "store_management.services.interfaces.order_service.IOrderService",
        "store_management.database.sqlalchemy.core.specialized.order_manager.OrderManager"
      ],
      "classes": [
        {
          "name": "OrderService",
          "docstring": "Service for order management operations",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize with appropriate managers.\n\nArgs:\n    container: Dependency injection container",
              "args": [
                "self",
                "container"
              ]
            },
            {
              "name": "get_all_orders",
              "docstring": "Retrieve all orders.\n\nReturns:\n    List of order dictionaries",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_order_by_id",
              "docstring": "Get order details by ID.\n\nArgs:\n    order_id: Order ID\n\nReturns:\n    Order details or None if not found",
              "args": [
                "self",
                "order_id"
              ]
            },
            {
              "name": "create_order",
              "docstring": "Create a new order.\n\nArgs:\n    order_data: Dictionary with order data\n\nReturns:\n    Created order or None",
              "args": [
                "self",
                "order_data"
              ]
            },
            {
              "name": "update_order",
              "docstring": "Update an existing order.\n\nArgs:\n    order_data: Dictionary with updated order information\n\nReturns:\n    Updated order or None",
              "args": [
                "self",
                "order_data"
              ]
            },
            {
              "name": "delete_order",
              "docstring": "Delete an order.\n\nArgs:\n    order_id: ID of the order to delete\n\nReturns:\n    True if deletion successful, False otherwise",
              "args": [
                "self",
                "order_id"
              ]
            },
            {
              "name": "_to_dict",
              "docstring": "Convert order model to dictionary.\n\nArgs:\n    order: Order model instance\n\nReturns:\n    Dictionary representation of the order",
              "args": [
                "self",
                "order"
              ]
            }
          ],
          "base_classes": [
            "Service",
            "IOrderService"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "services\\implementations\\recipe_service.py": {
      "path": "services\\implementations\\recipe_service.py",
      "imports": [
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "typing.Tuple",
        "store_management.di.service.Service",
        "store_management.di.container.DependencyContainer",
        "store_management.services.interfaces.recipe_service.IRecipeService",
        "store_management.database.sqlalchemy.core.specialized.recipe_manager.RecipeManager"
      ],
      "classes": [
        {
          "name": "RecipeService",
          "docstring": "Service for recipe management operations",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize with appropriate managers.\n\nArgs:\n    container: Dependency injection container",
              "args": [
                "self",
                "container"
              ]
            },
            {
              "name": "get_all_recipes",
              "docstring": "Retrieve all recipes.\n\nReturns:\n    List of recipe dictionaries",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_recipe_by_id",
              "docstring": "Get recipe details by ID.\n\nArgs:\n    recipe_id: Recipe ID\n\nReturns:\n    Recipe details or None if not found",
              "args": [
                "self",
                "recipe_id"
              ]
            },
            {
              "name": "create_recipe",
              "docstring": "Create a new recipe with items.\n\nArgs:\n    recipe_data: Dictionary with recipe data\n    items: Optional list of recipe item data\n\nReturns:\n    Tuple of (created recipe or None, result message)",
              "args": [
                "self",
                "recipe_data",
                "items"
              ]
            },
            {
              "name": "update_recipe",
              "docstring": "Update an existing recipe.\n\nArgs:\n    recipe_id: ID of the recipe to update\n    recipe_data:\n    Updated recipe data\n    items: Optional list of recipe item data\n\nReturns:\n    Updated recipe or None",
              "args": [
                "self",
                "recipe_id",
                "recipe_data",
                "items"
              ]
            },
            {
              "name": "delete_recipe",
              "docstring": "Delete a recipe.\n\nArgs:\n    recipe_id: ID of the recipe to delete\n\nReturns:\n    True if deletion successful, False otherwise",
              "args": [
                "self",
                "recipe_id"
              ]
            },
            {
              "name": "check_materials_availability",
              "docstring": "Check if materials for a recipe are available in sufficient quantity.\n\nArgs:\n    recipe_id: Recipe ID\n    quantity: Number of items to produce\n\nReturns:\n    Tuple of (all materials available, list of missing items)",
              "args": [
                "self",
                "recipe_id",
                "quantity"
              ]
            },
            {
              "name": "_to_dict",
              "docstring": "Convert recipe model to dictionary.\n\nArgs:\n    recipe: Recipe model instance\n\nReturns:\n    Dictionary representation of the recipe",
              "args": [
                "self",
                "recipe"
              ]
            }
          ],
          "base_classes": [
            "Service",
            "IRecipeService"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "services\\implementations\\shopping_list_service.py": {
      "path": "services\\implementations\\shopping_list_service.py",
      "imports": [
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "typing.Tuple",
        "typing.cast",
        "datetime.datetime",
        "store_management.di.service.Service",
        "store_management.di.container.DependencyContainer",
        "store_management.services.interfaces.shopping_list_service.IShoppingListService",
        "store_management.database.sqlalchemy.base_manager.BaseManager",
        "store_management.database.sqlalchemy.models.shopping_list.ShoppingList",
        "store_management.database.sqlalchemy.models.shopping_list.ShoppingListItem",
        "store_management.database.sqlalchemy.models.part.Part",
        "store_management.database.sqlalchemy.models.leather.Leather",
        "store_management.database.sqlalchemy.models.supplier.Supplier"
      ],
      "classes": [
        {
          "name": "ShoppingListService",
          "docstring": "Service for shopping list management operations",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize with appropriate managers",
              "args": [
                "self",
                "container"
              ]
            },
            {
              "name": "create_shopping_list",
              "docstring": "Create a new shopping list with optional items.\n\nArgs:\n    list_data: Shopping list data\n    items: Optional list of item data\n\nReturns:\n    Tuple of (created shopping list or None, result message)",
              "args": [
                "self",
                "list_data",
                "items"
              ]
            },
            {
              "name": "add_item_to_list",
              "docstring": "Add an item to a shopping list.\n\nArgs:\n    list_id: Shopping list ID\n    item_data: Item data\n\nReturns:\n    Tuple of (created item or None, result message)",
              "args": [
                "self",
                "list_id",
                "item_data"
              ]
            },
            {
              "name": "mark_item_purchased",
              "docstring": "Mark a shopping list item as purchased with purchase details.\n\nArgs:\n    item_id: Shopping list item ID\n    purchase_data: Purchase details (date, price)\n\nReturns:\n    Tuple of (success, message)",
              "args": [
                "self",
                "item_id",
                "purchase_data"
              ]
            },
            {
              "name": "get_pending_items_by_supplier",
              "docstring": "Get pending items grouped by supplier.\n\nReturns:\n    Dictionary mapping supplier IDs to lists of pending items",
              "args": [
                "self"
              ]
            },
            {
              "name": "_get_shopping_list_with_items",
              "docstring": "Get shopping list with its items.\n\nArgs:\n    list_id: Shopping list ID\n\nReturns:\n    Dictionary with shopping list and items or None if not found",
              "args": [
                "self",
                "list_id"
              ]
            },
            {
              "name": "_shopping_list_to_dict",
              "docstring": "Convert ShoppingList model to dictionary.",
              "args": [
                "self",
                "shopping_list"
              ]
            },
            {
              "name": "_shopping_list_item_to_dict",
              "docstring": "Convert ShoppingListItem model to dictionary.",
              "args": [
                "self",
                "item"
              ]
            }
          ],
          "base_classes": [
            "Service",
            "IShoppingListService"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "services\\implementations\\storage_service.py": {
      "path": "services\\implementations\\storage_service.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "store_management.di.service.Service",
        "store_management.di.container.DependencyContainer",
        "store_management.services.interfaces.storage_service.IStorageService",
        "store_management.database.sqlalchemy.core.specialized.storage_manager.StorageManager"
      ],
      "classes": [
        {
          "name": "StorageService",
          "docstring": "Concrete implementation of the IStorageService interface.\n\nThis class provides methods for managing storage locations and their inventory.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize StorageService with a dependency container.\n\nArgs:\n    container: Dependency injection container",
              "args": [
                "self",
                "container"
              ]
            },
            {
              "name": "get_all_storage_locations",
              "docstring": "Retrieve all storage locations.\n\nReturns:\n    A list of dictionaries, each representing a storage location.",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_storage_by_id",
              "docstring": "Retrieve a specific storage location by its ID.\n\nArgs:\n    storage_id: The unique identifier of the storage location.\n\nReturns:\n    A dictionary representing the storage location if found, None otherwise.",
              "args": [
                "self",
                "storage_id"
              ]
            },
            {
              "name": "create_storage_location",
              "docstring": "Create a new storage location.\n\nArgs:\n    storage_data: Dictionary containing storage location information\n\nReturns:\n    Created storage location dictionary or None if creation fails",
              "args": [
                "self",
                "storage_data"
              ]
            },
            {
              "name": "update_storage_location",
              "docstring": "Update an existing storage location.\n\nArgs:\n    storage_id: ID of the storage location to update\n    storage_data: Dictionary with updated storage location information\n\nReturns:\n    Updated storage location dictionary or None if update fails",
              "args": [
                "self",
                "storage_id",
                "storage_data"
              ]
            },
            {
              "name": "delete_storage_location",
              "docstring": "Delete a storage location.\n\nArgs:\n    storage_id: ID of the storage location to delete\n\nReturns:\n    True if deletion was successful, False otherwise",
              "args": [
                "self",
                "storage_id"
              ]
            },
            {
              "name": "search_storage_locations",
              "docstring": "Search storage locations by location or description.\n\nArgs:\n    search_term: Term to search for\n\nReturns:\n    List of matching storage locations",
              "args": [
                "self",
                "search_term"
              ]
            },
            {
              "name": "get_storage_status",
              "docstring": "Get detailed status of a storage location.\n\nArgs:\n    storage_id: ID of the storage location\n\nReturns:\n    Dictionary containing storage status details or None",
              "args": [
                "self",
                "storage_id"
              ]
            },
            {
              "name": "_to_dict",
              "docstring": "Convert storage model to dictionary.\n\nArgs:\n    storage: Storage model instance\n\nReturns:\n    Dictionary representation of the storage location",
              "args": [
                "self",
                "storage"
              ]
            }
          ],
          "base_classes": [
            "Service",
            "IStorageService"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "services\\implementations\\supplier_service.py": {
      "path": "services\\implementations\\supplier_service.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "store_management.di.service.Service",
        "store_management.di.container.DependencyContainer",
        "store_management.services.interfaces.supplier_service.ISupplierService",
        "store_management.database.sqlalchemy.core.specialized.supplier_manager.SupplierManager"
      ],
      "classes": [
        {
          "name": "SupplierService",
          "docstring": "Concrete implementation of the ISupplierService interface.\n\nProvides methods for managing supplier-related operations using the SupplierManager.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the SupplierService with a dependency container.\n\nArgs:\n    container: Dependency injection container",
              "args": [
                "self",
                "container"
              ]
            },
            {
              "name": "get_all_suppliers",
              "docstring": "Retrieve all suppliers.\n\nReturns:\n    List of dictionaries containing supplier information",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_supplier_by_id",
              "docstring": "Retrieve a supplier by their ID.\n\nArgs:\n    supplier_id: The unique identifier of the supplier\n\nReturns:\n    Dictionary containing supplier information or None if not found",
              "args": [
                "self",
                "supplier_id"
              ]
            },
            {
              "name": "create_supplier",
              "docstring": "Create a new supplier.\n\nArgs:\n    supplier_data: Dictionary containing the new supplier's information\n\nReturns:\n    Dictionary containing the created supplier's information",
              "args": [
                "self",
                "supplier_data"
              ]
            },
            {
              "name": "update_supplier",
              "docstring": "Update an existing supplier's information.\n\nArgs:\n    supplier_id: The unique identifier of the supplier to update\n    supplier_data: Dictionary containing the updated supplier information\n\nReturns:\n    Updated supplier information or None if update fails",
              "args": [
                "self",
                "supplier_id",
                "supplier_data"
              ]
            },
            {
              "name": "delete_supplier",
              "docstring": "Delete a supplier by their ID.\n\nArgs:\n    supplier_id: The unique identifier of the supplier to delete\n\nReturns:\n    True if the supplier was successfully deleted, False otherwise",
              "args": [
                "self",
                "supplier_id"
              ]
            },
            {
              "name": "_to_dict",
              "docstring": "Convert a supplier model to a dictionary.\n\nArgs:\n    supplier: Supplier model instance\n\nReturns:\n    Dictionary representation of the supplier",
              "args": [
                "self",
                "supplier"
              ]
            }
          ],
          "base_classes": [
            "Service",
            "ISupplierService"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "services\\implementations\\__init__.py": {
      "path": "services\\implementations\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "services\\interfaces\\base_service.py": {
      "path": "services\\interfaces\\base_service.py",
      "imports": [
        "abc.ABC",
        "abc.abstractmethod"
      ],
      "classes": [
        {
          "name": "IBaseService",
          "docstring": "Base interface for all services.\n\nThis abstract base class serves as a common ancestor for all service interfaces\nin the application. It doesn't define any methods itself but acts as a marker\ninterface to identify service classes.",
          "methods": [],
          "base_classes": [
            "ABC"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "services\\interfaces\\inventory_service.py": {
      "path": "services\\interfaces\\inventory_service.py",
      "imports": [
        "abc.ABC",
        "abc.abstractmethod",
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Tuple"
      ],
      "classes": [
        {
          "name": "IInventoryService",
          "docstring": "Interface for inventory management operations.",
          "methods": [
            {
              "name": "update_part_stock",
              "docstring": "Update part stock with transaction tracking.\n\nArgs:\n    part_id: Part ID\n    quantity_change: Change in quantity (positive or negative)\n    transaction_type: Type of transaction\n    notes: Optional notes\n\nReturns:\n    Tuple of (success, message)",
              "args": [
                "self",
                "part_id",
                "quantity_change",
                "transaction_type",
                "notes"
              ]
            },
            {
              "name": "update_leather_area",
              "docstring": "Update leather area with transaction tracking.\n\nArgs:\n    leather_id: Leather ID\n    area_change: Change in area (positive or negative)\n    transaction_type: Type of transaction\n    notes: Optional notes\n    wastage: Optional wastage area\n\nReturns:\n    Tuple of (success, message)",
              "args": [
                "self",
                "leather_id",
                "area_change",
                "transaction_type",
                "notes",
                "wastage"
              ]
            },
            {
              "name": "get_low_stock_parts",
              "docstring": "Get parts with low stock levels.\n\nArgs:\n    include_out_of_stock: Whether to include out of stock items\n\nReturns:\n    List of parts with low stock",
              "args": [
                "self",
                "include_out_of_stock"
              ]
            },
            {
              "name": "get_low_stock_leather",
              "docstring": "Get leather with low stock levels.\n\nArgs:\n    include_out_of_stock: Whether to include out of stock items\n\nReturns:\n    List of leather with low stock",
              "args": [
                "self",
                "include_out_of_stock"
              ]
            }
          ],
          "base_classes": [
            "ABC"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "services\\interfaces\\order_service.py": {
      "path": "services\\interfaces\\order_service.py",
      "imports": [
        "abc.ABC",
        "abc.abstractmethod",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "typing.Tuple",
        "store_management.services.interfaces.base_service.IBaseService"
      ],
      "classes": [
        {
          "name": "IOrderService",
          "docstring": "Interface for order management operations.\n\nDefines the contract for services handling order-related functionality.",
          "methods": [
            {
              "name": "get_all_orders",
              "docstring": "Retrieve all orders.\n\nReturns:\n    List of order dictionaries",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_order_by_id",
              "docstring": "Get order details by ID.\n\nArgs:\n    order_id: Order ID\n\nReturns:\n    Order details or None if not found",
              "args": [
                "self",
                "order_id"
              ]
            },
            {
              "name": "create_order",
              "docstring": "Create a new order.\n\nArgs:\n    order_data: Dictionary with order data\n\nReturns:\n    Created order or None",
              "args": [
                "self",
                "order_data"
              ]
            },
            {
              "name": "update_order",
              "docstring": "Update an existing order.\n\nArgs:\n    order_data: Dictionary with updated order information\n\nReturns:\n    Updated order or None",
              "args": [
                "self",
                "order_data"
              ]
            },
            {
              "name": "delete_order",
              "docstring": "Delete an order.\n\nArgs:\n    order_id: ID of the order to delete\n\nReturns:\n    True if deletion successful, False otherwise",
              "args": [
                "self",
                "order_id"
              ]
            }
          ],
          "base_classes": [
            "IBaseService"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "services\\interfaces\\recipe_service.py": {
      "path": "services\\interfaces\\recipe_service.py",
      "imports": [
        "abc.ABC",
        "abc.abstractmethod",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "typing.Tuple",
        "store_management.services.interfaces.base_service.IBaseService"
      ],
      "classes": [
        {
          "name": "IRecipeService",
          "docstring": "Interface for recipe management operations.\n\nDefines the contract for services handling recipe-related functionality.",
          "methods": [
            {
              "name": "get_all_recipes",
              "docstring": "Retrieve all recipes.\n\nReturns:\n    List of recipe dictionaries",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_recipe_by_id",
              "docstring": "Get recipe details by ID.\n\nArgs:\n    recipe_id: Recipe ID\n\nReturns:\n    Recipe details or None if not found",
              "args": [
                "self",
                "recipe_id"
              ]
            },
            {
              "name": "create_recipe",
              "docstring": "Create a new recipe with items.\n\nArgs:\n    recipe_data: Dictionary with recipe data\n    items: Optional list of recipe item data\n\nReturns:\n    Created recipe or None",
              "args": [
                "self",
                "recipe_data",
                "items"
              ]
            },
            {
              "name": "update_recipe",
              "docstring": "Update an existing recipe.\n\nArgs:\n    recipe_id: ID of the recipe to update\n    recipe_data: Updated recipe data\n    items: Optional list of updated recipe items\n\nReturns:\n    Updated recipe or None",
              "args": [
                "self",
                "recipe_id",
                "recipe_data",
                "items"
              ]
            },
            {
              "name": "delete_recipe",
              "docstring": "Delete a recipe.\n\nArgs:\n    recipe_id: ID of the recipe to delete\n\nReturns:\n    True if deletion successful, False otherwise",
              "args": [
                "self",
                "recipe_id"
              ]
            },
            {
              "name": "check_materials_availability",
              "docstring": "Check if materials for a recipe are available in sufficient quantity.\n\nArgs:\n    recipe_id: Recipe ID\n    quantity: Number of items to produce\n\nReturns:\n    Tuple of (all materials available, list of missing items)",
              "args": [
                "self",
                "recipe_id",
                "quantity"
              ]
            }
          ],
          "base_classes": [
            "IBaseService"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "services\\interfaces\\shopping_list_service.py": {
      "path": "services\\interfaces\\shopping_list_service.py",
      "imports": [
        "abc.ABC",
        "abc.abstractmethod",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "typing.Tuple",
        "store_management.services.interfaces.base_service.IBaseService"
      ],
      "classes": [
        {
          "name": "IShoppingListService",
          "docstring": "Interface for shopping list management operations.\n\nDefines the contract for services handling shopping list-related functionality.",
          "methods": [
            {
              "name": "get_all_shopping_lists",
              "docstring": "Retrieve all shopping lists.\n\nReturns:\n    List of shopping list dictionaries",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_shopping_list_by_id",
              "docstring": "Get shopping list details by ID.\n\nArgs:\n    list_id: Shopping list ID\n\nReturns:\n    Shopping list details or None if not found",
              "args": [
                "self",
                "list_id"
              ]
            },
            {
              "name": "create_shopping_list",
              "docstring": "Create a new shopping list with optional items.\n\nArgs:\n    list_data: Shopping list data\n    items: Optional list of item data\n\nReturns:\n    Created shopping list or None",
              "args": [
                "self",
                "list_data",
                "items"
              ]
            },
            {
              "name": "update_shopping_list",
              "docstring": "Update an existing shopping list.\n\nArgs:\n    list_id: ID of the shopping list to update\n    list_data: Updated shopping list data\n    items: Optional list of updated items\n\nReturns:\n    Updated shopping list or None",
              "args": [
                "self",
                "list_id",
                "list_data",
                "items"
              ]
            },
            {
              "name": "delete_shopping_list",
              "docstring": "Delete a shopping list.\n\nArgs:\n    list_id: ID of the shopping list to delete\n\nReturns:\n    True if deletion successful, False otherwise",
              "args": [
                "self",
                "list_id"
              ]
            },
            {
              "name": "add_item_to_list",
              "docstring": "Add an item to a shopping list.\n\nArgs:\n    list_id: Shopping list ID\n    item_data: Item data to add\n\nReturns:\n    Added item or None",
              "args": [
                "self",
                "list_id",
                "item_data"
              ]
            },
            {
              "name": "remove_item_from_list",
              "docstring": "Remove an item from a shopping list.\n\nArgs:\n    list_id: Shopping list ID\n    item_id: Item ID to remove\n\nReturns:\n    True if removal successful, False otherwise",
              "args": [
                "self",
                "list_id",
                "item_id"
              ]
            },
            {
              "name": "mark_item_purchased",
              "docstring": "Mark a shopping list item as purchased.\n\nArgs:\n    item_id: Shopping list item ID\n    purchase_data: Purchase details\n\nReturns:\n    Updated item or None",
              "args": [
                "self",
                "item_id",
                "purchase_data"
              ]
            },
            {
              "name": "search_shopping_lists",
              "docstring": "Search shopping lists by name or description.\n\nArgs:\n    search_term: Term to search for\n\nReturns:\n    List of matching shopping lists",
              "args": [
                "self",
                "search_term"
              ]
            }
          ],
          "base_classes": [
            "IBaseService"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "services\\interfaces\\storage_service.py": {
      "path": "services\\interfaces\\storage_service.py",
      "imports": [
        "abc.ABC",
        "abc.abstractmethod",
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "store_management.services.interfaces.base_service.IBaseService"
      ],
      "classes": [
        {
          "name": "IStorageService",
          "docstring": "Interface for storage-related operations.\n\nDefines the contract for services managing storage locations\nThis interface establishes a standard set of methods for interacting\nwith storage locations in the application.",
          "methods": [
            {
              "name": "get_all_storage_locations",
              "docstring": "Retrieve all storage locations.\n\nReturns:\n    A list of dictionaries, each representing a storage location.",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_storage_by_id",
              "docstring": "Retrieve a specific storage location by its ID.\n\nArgs:\n    storage_id: The unique identifier of the storage location.\n\nReturns:\n    A dictionary representing the storage location if found, None otherwise.",
              "args": [
                "self",
                "storage_id"
              ]
            },
            {
              "name": "create_storage_location",
              "docstring": "Create a new storage location.\n\nArgs:\n    storage_data: Dictionary containing storage location information\n\nReturns:\n    Created storage location dictionary or None if creation fails",
              "args": [
                "self",
                "storage_data"
              ]
            },
            {
              "name": "update_storage_location",
              "docstring": "Update an existing storage location.\n\nArgs:\n    storage_id: ID of the storage location to update\n    storage_data: Dictionary with updated storage location information\n\nReturns:\n    Updated storage location dictionary or None if update fails",
              "args": [
                "self",
                "storage_id",
                "storage_data"
              ]
            },
            {
              "name": "delete_storage_location",
              "docstring": "Delete a storage location.\n\nArgs:\n    storage_id: ID of the storage location to delete\n\nReturns:\n    True if deletion was successful, False otherwise",
              "args": [
                "self",
                "storage_id"
              ]
            },
            {
              "name": "search_storage_locations",
              "docstring": "Search storage locations by location or description.\n\nArgs:\n    search_term: Term to search for\n\nReturns:\n    List of matching storage locations",
              "args": [
                "self",
                "search_term"
              ]
            },
            {
              "name": "get_storage_status",
              "docstring": "Get detailed status of a storage location.\n\nArgs:\n    storage_id: ID of the storage location\n\nReturns:\n    Dictionary containing storage status details or None",
              "args": [
                "self",
                "storage_id"
              ]
            }
          ],
          "base_classes": [
            "IBaseService"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "services\\interfaces\\supplier_service.py": {
      "path": "services\\interfaces\\supplier_service.py",
      "imports": [
        "abc.ABC",
        "abc.abstractmethod",
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "store_management.services.interfaces.base_service.IBaseService"
      ],
      "classes": [
        {
          "name": "ISupplierService",
          "docstring": "Abstract base class defining the interface for supplier-related operations.\n\nThis interface provides a contract for supplier management services,\nensuring consistent method signatures across different implementations.",
          "methods": [
            {
              "name": "get_all_suppliers",
              "docstring": "Retrieve all suppliers.\n\nReturns:\n    List[Dict[str, Any]]: A list of dictionaries containing supplier information.",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_supplier_by_id",
              "docstring": "Retrieve a supplier by their ID.\n\nArgs:\n    supplier_id (int): The unique identifier of the supplier.\n\nReturns:\n    Optional[Dict[str, Any]]: A dictionary containing supplier information if found, None otherwise.",
              "args": [
                "self",
                "supplier_id"
              ]
            },
            {
              "name": "create_supplier",
              "docstring": "Create a new supplier.\n\nArgs:\n    supplier_data (Dict[str, Any]): A dictionary containing the new supplier's information.\n\nReturns:\n    Optional[Dict[str, Any]]: A dictionary containing the created supplier's information.",
              "args": [
                "self",
                "supplier_data"
              ]
            },
            {
              "name": "update_supplier",
              "docstring": "Update an existing supplier's information.\n\nArgs:\n    supplier_id (int): The unique identifier of the supplier to update.\n    supplier_data (Dict[str, Any]): A dictionary containing the updated supplier information.\n\nReturns:\n    Optional[Dict[str, Any]]: A dictionary containing the updated supplier information if successful, None otherwise.",
              "args": [
                "self",
                "supplier_id",
                "supplier_data"
              ]
            },
            {
              "name": "delete_supplier",
              "docstring": "Delete a supplier by their ID.\n\nArgs:\n    supplier_id (int): The unique identifier of the supplier to delete.\n\nReturns:\n    bool: True if the supplier was successfully deleted, False otherwise.",
              "args": [
                "self",
                "supplier_id"
              ]
            }
          ],
          "base_classes": [
            "IBaseService"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "services\\interfaces\\__init__.py": {
      "path": "services\\interfaces\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "services\\services\\storage_service.py": {
      "path": "services\\services\\storage_service.py",
      "imports": [
        "abc.ABC",
        "abc.abstractmethod",
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any"
      ],
      "classes": [
        {
          "name": "IStorageService",
          "docstring": "Interface for storage service operations.",
          "methods": [
            {
              "name": "get_all_storage_locations",
              "docstring": "Get all storage locations.",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_storage_by_id",
              "docstring": "Get a storage location by ID.",
              "args": [
                "self",
                "storage_id"
              ]
            }
          ],
          "base_classes": [
            "ABC"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "services\\services\\__init__.py": {
      "path": "services\\services\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "services\\services\\implementations\\stoarage_service.py": {
      "path": "services\\services\\implementations\\stoarage_service.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Type",
        "typing.cast",
        "store_management.di.service.Service",
        "store_management.di.container.DependencyContainer",
        "store_management.services.interfaces.storage_service.IStorageService",
        "store_management.database.sqlalchemy.base_manager.BaseManager",
        "store_management.database.sqlalchemy.models.storage.Storage"
      ],
      "classes": [
        {
          "name": "StorageService",
          "docstring": "Service for managing storage locations and their inventory.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "container"
              ]
            },
            {
              "name": "get_all_storage_locations",
              "docstring": "Get all storage locations.",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_storage_by_id",
              "docstring": "Get a storage location by ID.",
              "args": [
                "self",
                "storage_id"
              ]
            },
            {
              "name": "_to_dict",
              "docstring": "Convert Storage model to dictionary.",
              "args": [
                "self",
                "storage"
              ]
            }
          ],
          "base_classes": [
            "Service",
            "IStorageService"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "services\\services\\implementations\\__init__.py": {
      "path": "services\\services\\implementations\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "gui\\dialogs\\add_dialog.py": {
      "path": "gui\\dialogs\\add_dialog.py",
      "imports": [
        "tkinter",
        "tkinter.ttk",
        "tkinter.messagebox",
        "typing.Dict",
        "typing.Callable",
        "typing.Optional",
        "typing.List",
        "typing.Union",
        "typing.Tuple",
        "uuid",
        "typing.Dict",
        "typing.Callable",
        "typing.Optional",
        "typing.List",
        "typing.Union",
        "typing.Tuple",
        "typing.Any"
      ],
      "classes": [
        {
          "name": "AddDialog",
          "docstring": "A flexible dialog for adding new entries with dynamic field generation.\n\nSupports different field types and provides validation mechanisms.\n\nAttributes:\n    _parent: Parent window\n    _save_callback: Function to call when save is triggered\n    _fields: List of field configurations\n    _entries: Dictionary to store entry widgets",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the add dialog.\n\nArgs:\n    parent: Parent window\n    save_callback: Function called with form data on save\n    fields: List of field tuples (field_name, display_name, required, field_type)\n    title: Dialog title\n\nField Types:\n    - 'string': Text entry\n    - 'text': Multiline text entry\n    - 'float': Numeric entry (floating-point)\n    - 'int': Integer entry\n    - 'boolean': Checkbox",
              "args": [
                "self",
                "parent",
                "save_callback",
                "fields",
                "title"
              ]
            },
            {
              "name": "_create_ui",
              "docstring": "Create dialog user interface with dynamic fields.",
              "args": [
                "self"
              ]
            },
            {
              "name": "_on_save",
              "docstring": "Handle save action, validate and process form data.",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "tk.Toplevel"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "gui\\dialogs\\base_dialog.py": {
      "path": "gui\\dialogs\\base_dialog.py",
      "imports": [
        "tkinter",
        "tkinter.ttk",
        "typing.Optional",
        "typing.Tuple",
        "typing.Callable"
      ],
      "classes": [
        {
          "name": "BaseDialog",
          "docstring": "Base class for all dialog windows in the application.\n\nProvides common dialog functionality:\n- Centered positioning\n- Standardized button layout\n- Modal window support\n- Basic validation mechanism\n\nAttributes:\n    parent (tk.Tk or tk.Toplevel): Parent window\n    title (str): Dialog title\n    size (Optional[Tuple[int, int]]): Optional dialog size\n    modal (bool): Whether the dialog should be modal",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the base dialog.\n\nArgs:\n    parent: Parent window\n    title: Dialog title\n    size: Optional dialog size (width, height)\n    modal: Whether the dialog should block parent window interaction",
              "args": [
                "self",
                "parent",
                "title",
                "size",
                "modal"
              ]
            },
            {
              "name": "_create_main_frame",
              "docstring": "Create the main content frame for dialog content.\nSubclasses should override and add specific content.",
              "args": [
                "self"
              ]
            },
            {
              "name": "_create_button_frame",
              "docstring": "Create a standard button frame with OK and Cancel buttons.",
              "args": [
                "self"
              ]
            },
            {
              "name": "add_ok_cancel_buttons",
              "docstring": "Add standard OK and Cancel buttons to the dialog.\n\nArgs:\n    ok_text: Text for the OK button\n    cancel_text: Text for the Cancel button\n    ok_command: Optional custom command for OK button",
              "args": [
                "self",
                "ok_text",
                "cancel_text",
                "ok_command"
              ]
            },
            {
              "name": "add_button",
              "docstring": "Add a custom button to the button frame.\n\nArgs:\n    text: Button text\n    command: Button click command\n    side: Side to pack the button (default: right)\n    width: Button width\n    default: Whether this is the default button\n\nReturns:\n    The created button",
              "args": [
                "self",
                "text",
                "command",
                "side",
                "width",
                "default"
              ]
            },
            {
              "name": "center_on_parent",
              "docstring": "Center the dialog on its parent window.",
              "args": [
                "self"
              ]
            },
            {
              "name": "ok",
              "docstring": "Standard OK button handler.\nSubclasses should override to add specific validation logic.\n\nArgs:\n    event: Optional tkinter event",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "cancel",
              "docstring": "Standard Cancel button handler.\n\nArgs:\n    event: Optional tkinter event",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "validate",
              "docstring": "Validate dialog contents before closing.\n\nSubclasses should override to implement specific validation.\n\nReturns:\n    True if validation passes, False otherwise",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "tk.Toplevel"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "gui\\dialogs\\filter_dialog.py": {
      "path": "gui\\dialogs\\filter_dialog.py",
      "imports": [
        "tkinter",
        "tkinter.ttk",
        "typing.List",
        "typing.Callable",
        "typing.Dict"
      ],
      "classes": [
        {
          "name": "FilterDialog",
          "docstring": "",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize filter dialog\n\nArgs:\n    parent: Parent window\n    columns: List of column names to filter on\n    filter_callback: Function to call with filter conditions",
              "args": [
                "self",
                "parent",
                "columns",
                "filter_callback"
              ]
            },
            {
              "name": "setup_ui",
              "docstring": "Setup the dialog UI components",
              "args": [
                "self"
              ]
            },
            {
              "name": "add_filter",
              "docstring": "Add a new filter row",
              "args": [
                "self"
              ]
            },
            {
              "name": "remove_filter",
              "docstring": "Remove a filter row",
              "args": [
                "self",
                "filter_frame"
              ]
            },
            {
              "name": "get_filter_conditions",
              "docstring": "Get all filter conditions",
              "args": [
                "self"
              ]
            },
            {
              "name": "apply_filters",
              "docstring": "Apply all filter conditions",
              "args": [
                "self"
              ]
            },
            {
              "name": "validate_numeric_filter",
              "docstring": "Validate numeric filters",
              "args": [
                "self",
                "value",
                "column"
              ]
            },
            {
              "name": "clear_filters",
              "docstring": "Clear all filter conditions",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "tk.Toplevel"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "gui\\dialogs\\report_dialog.py": {
      "path": "gui\\dialogs\\report_dialog.py",
      "imports": [
        "tkinter",
        "tkinter.ttk",
        "tkinter.messagebox",
        "tkinter.filedialog",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "datetime.datetime",
        "csv",
        "store_management.database.sqlalchemy.manager.ReportManager",
        "store_management.database.sqlalchemy.session.get_session",
        "store_management.gui.dialogs.base_dialog.BaseDialog",
        "store_management.utils.logger.get_logger"
      ],
      "classes": [
        {
          "name": "ReportDialog",
          "docstring": "",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "parent"
              ]
            },
            {
              "name": "create_ui",
              "docstring": "Create the report dialog UI",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_report_display",
              "docstring": "Create the report display area",
              "args": [
                "self",
                "parent"
              ]
            },
            {
              "name": "update_options",
              "docstring": "Update visible options based on report type",
              "args": [
                "self"
              ]
            },
            {
              "name": "on_report_type_change",
              "docstring": "Handle report type change",
              "args": [
                "self"
              ]
            },
            {
              "name": "generate_report",
              "docstring": "Generate the selected report",
              "args": [
                "self"
              ]
            },
            {
              "name": "display_inventory_report",
              "docstring": "Display inventory report",
              "args": [
                "self"
              ]
            },
            {
              "name": "display_orders_report",
              "docstring": "Display orders report",
              "args": [
                "self"
              ]
            },
            {
              "name": "display_suppliers_report",
              "docstring": "Display suppliers report",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_treeview",
              "docstring": "Create a treeview with given columns and data",
              "args": [
                "self",
                "parent",
                "columns",
                "data"
              ]
            }
          ],
          "base_classes": [
            "BaseDialog"
          ]
        }
      ],
      "functions": [],
      "global_variables": [
        "logger"
      ]
    },
    "gui\\dialogs\\search_dialog.py": {
      "path": "gui\\dialogs\\search_dialog.py",
      "imports": [
        "tkinter",
        "tkinter.ttk",
        "typing.List",
        "typing.Callable",
        "typing.Dict"
      ],
      "classes": [
        {
          "name": "SearchDialog",
          "docstring": "",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize search dialog\n\nArgs:\n    parent: Parent window\n    columns: List of column names to search in\n    search_callback: Function to call with search parameters",
              "args": [
                "self",
                "parent",
                "columns",
                "search_callback"
              ]
            },
            {
              "name": "setup_ui",
              "docstring": "Setup the dialog UI components",
              "args": [
                "self"
              ]
            },
            {
              "name": "search",
              "docstring": "Execute the search",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "tk.Toplevel"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "gui\\dialogs\\__init__.py": {
      "path": "gui\\dialogs\\__init__.py",
      "imports": [
        "base_dialog.BaseDialog",
        "add_dialog.AddDialog",
        "search_dialog.SearchDialog",
        "filter_dialog.FilterDialog"
      ],
      "classes": [],
      "functions": [],
      "global_variables": [
        "__all__"
      ]
    },
    "gui\\order\\incoming_goods_view.py": {
      "path": "gui\\order\\incoming_goods_view.py",
      "imports": [
        "tkinter",
        "tkinter.ttk",
        "tkinter.messagebox",
        "tkinter.filedialog",
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "sqlalchemy.orm.Session",
        "store_management.database.sqlalchemy.models.Order",
        "store_management.database.sqlalchemy.models.OrderStatus",
        "store_management.database.sqlalchemy.models.PaymentStatus",
        "store_management.database.sqlalchemy.managers.order_manager.OrderManager",
        "store_management.utils.exporters.order_exporter.OrderExporter",
        "store_management.utils.validators.order_validator.OrderValidator",
        "store_management.gui.base_view.BaseView"
      ],
      "classes": [
        {
          "name": "IncomingGoodsView",
          "docstring": "View for managing incoming goods and orders",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize Incoming Goods View\n\nArgs:\n    parent: Parent widget\n    session: SQLAlchemy database session",
              "args": [
                "self",
                "parent",
                "session"
              ]
            },
            {
              "name": "_setup_ui",
              "docstring": "Setup the entire user interface",
              "args": [
                "self"
              ]
            },
            {
              "name": "_create_toolbar",
              "docstring": "Create the main toolbar with action buttons",
              "args": [
                "self"
              ]
            },
            {
              "name": "_create_content_area",
              "docstring": "Create main content area with orders and details tables",
              "args": [
                "self"
              ]
            },
            {
              "name": "_create_treeview",
              "docstring": "Create a standardized treeview\n\nArgs:\n    parent: Parent widget\n    columns: List of column names\n    select_callback: Optional selection callback\n\nReturns:\n    Configured Treeview widget",
              "args": [
                "parent",
                "columns",
                "select_callback"
              ]
            },
            {
              "name": "_load_initial_data",
              "docstring": "Load initial orders data",
              "args": [
                "self"
              ]
            },
            {
              "name": "_populate_orders_tree",
              "docstring": "Populate orders treeview\n\nArgs:\n    orders: List of Order objects",
              "args": [
                "self",
                "orders"
              ]
            },
            {
              "name": "_on_order_select",
              "docstring": "Handle order selection in treeview",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "_load_order_details",
              "docstring": "Load details for a specific order\n\nArgs:\n    order_id: ID of the order to load details for",
              "args": [
                "self",
                "order_id"
              ]
            },
            {
              "name": "cleanup",
              "docstring": "Cleanup resources and handle unsaved changes",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "BaseView"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "gui\\order\\order_dialog.py": {
      "path": "gui\\order\\order_dialog.py",
      "imports": [
        "tkinter",
        "tkinter.ttk",
        "tkinter.messagebox",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "typing.Callable",
        "datetime.datetime",
        "store_management.gui.dialogs.base_dialog.BaseDialog"
      ],
      "classes": [
        {
          "name": "AddOrderDialog",
          "docstring": "Flexible dialog for creating and editing orders.\n\nSupports:\n- Dynamic field generation\n- Supplier selection\n- Validation\n- Editing existing orders",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the order dialog.\n\nArgs:\n    parent: Parent window\n    save_callback: Function to call when saving order\n    fields: Optional list of field configurations\n    suppliers: List of available suppliers\n    existing_data: Existing order data for editing\n    title: Dialog title",
              "args": [
                "self",
                "parent",
                "save_callback",
                "fields",
                "suppliers",
                "existing_data",
                "title"
              ]
            },
            {
              "name": "_create_main_frame",
              "docstring": "Create dialog main frame with dynamic fields and order items section.",
              "args": [
                "self"
              ]
            },
            {
              "name": "_create_order_details_fields",
              "docstring": "Create dynamic fields for order details.\n\nArgs:\n    parent: Parent frame to add fields to",
              "args": [
                "self",
                "parent"
              ]
            },
            {
              "name": "_create_order_items_section",
              "docstring": "Create section for managing order items.\n\nArgs:\n    parent: Parent frame to add items section to",
              "args": [
                "self",
                "parent"
              ]
            },
            {
              "name": "_show_add_item_dialog",
              "docstring": "Show dialog to add a new order item.",
              "args": [
                "self"
              ]
            },
            {
              "name": "_remove_selected_item",
              "docstring": "Remove selected order item.",
              "args": [
                "self"
              ]
            },
            {
              "name": "ok",
              "docstring": "Save order data when OK is pressed.\n\nArgs:\n    event: Optional tkinter event",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "validate",
              "docstring": "Validate order data before saving.\n\nReturns:\n    True if validation passes, False otherwise",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "BaseDialog"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "gui\\order\\order_view.py": {
      "path": "gui\\order\\order_view.py",
      "imports": [
        "tkinter",
        "tkinter.ttk",
        "tkinter.messagebox",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "store_management.application.Application",
        "store_management.gui.base_view.BaseView",
        "store_management.services.interfaces.order_service.IOrderService",
        "store_management.services.interfaces.supplier_service.ISupplierService"
      ],
      "classes": [
        {
          "name": "OrderView",
          "docstring": "Comprehensive view for managing orders with:\n- Treeview for listing orders\n- Detailed order information display\n- Actions for creating, editing, and managing orders",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the Order View.\n\nArgs:\n    parent: Parent widget\n    app: Application instance",
              "args": [
                "self",
                "parent",
                "app"
              ]
            },
            {
              "name": "setup_ui",
              "docstring": "Set up the UI components.",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_toolbar",
              "docstring": "Create toolbar with order management actions.",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_order_list",
              "docstring": "Create treeview to display list of orders.",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_order_details",
              "docstring": "Create detailed view for selected order.",
              "args": [
                "self"
              ]
            },
            {
              "name": "load_data",
              "docstring": "Load orders from the order service.",
              "args": [
                "self"
              ]
            },
            {
              "name": "show_add_order_dialog",
              "docstring": "Show dialog to add a new order.",
              "args": [
                "self"
              ]
            },
            {
              "name": "_save_new_order",
              "docstring": "Save a new order.\n\nArgs:\n    order_data: Dictionary containing order information",
              "args": [
                "self",
                "order_data"
              ]
            },
            {
              "name": "_on_order_select",
              "docstring": "Handle order selection in treeview.\n\nArgs:\n    event: Tkinter event (optional)",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "_load_order_details",
              "docstring": "Load details for a specific order.\n\nArgs:\n    order_id: ID of the order to load details for",
              "args": [
                "self",
                "order_id"
              ]
            },
            {
              "name": "_edit_order",
              "docstring": "Edit the selected order.",
              "args": [
                "self"
              ]
            },
            {
              "name": "_save_edited_order",
              "docstring": "Save edited order details.\n\nArgs:\n    order_data: Updated order information",
              "args": [
                "self",
                "order_data"
              ]
            },
            {
              "name": "delete_order",
              "docstring": "Delete the selected order.",
              "args": [
                "self"
              ]
            },
            {
              "name": "_show_search_dialog",
              "docstring": "Show search dialog for orders.",
              "args": [
                "self"
              ]
            },
            {
              "name": "save",
              "docstring": "Save current view data.",
              "args": [
                "self"
              ]
            },
            {
              "name": "undo",
              "docstring": "Undo the last action.",
              "args": [
                "self"
              ]
            },
            {
              "name": "redo",
              "docstring": "Redo the last undone action.",
              "args": [
                "self"
              ]
            },
            {
              "name": "cleanup",
              "docstring": "Perform cleanup when view is closed.",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "BaseView"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "gui\\order\\shopping_list_view.py": {
      "path": "gui\\order\\shopping_list_view.py",
      "imports": [
        "tkinter",
        "tkinter.ttk",
        "tkinter.messagebox",
        "sqlalchemy.exc.SQLAlchemyError",
        "typing.Optional",
        "typing.List",
        "datetime.datetime",
        "store_management.database.sqlalchemy.models.ShoppingList",
        "store_management.database.sqlalchemy.models.ShoppingListItem",
        "store_management.database.sqlalchemy.models.Supplier",
        "store_management.database.sqlalchemy.models.Part",
        "store_management.database.sqlalchemy.models.Leather",
        "store_management.database.sqlalchemy.manager.DatabaseManagerSQLAlchemy"
      ],
      "classes": [
        {
          "name": "ShoppingListView",
          "docstring": "",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "parent"
              ]
            },
            {
              "name": "setup_table_selection",
              "docstring": "Create shopping list selection table view",
              "args": [
                "self"
              ]
            },
            {
              "name": "load_shopping_lists",
              "docstring": "Load available shopping lists",
              "args": [
                "self"
              ]
            },
            {
              "name": "show_add_list_dialog",
              "docstring": "Show dialog for creating new shopping list",
              "args": [
                "self"
              ]
            },
            {
              "name": "on_list_select",
              "docstring": "Handle shopping list selection",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "load_list_items",
              "docstring": "Load items for selected shopping list",
              "args": [
                "self",
                "list_id"
              ]
            },
            {
              "name": "show_add_item_dialog",
              "docstring": "Show dialog for adding item to shopping list",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "ttk.Frame"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "gui\\order\\supplier_view.py": {
      "path": "gui\\order\\supplier_view.py",
      "imports": [
        "tkinter",
        "tkinter.ttk",
        "tkinter.messagebox",
        "tkinter.filedialog",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "datetime.datetime",
        "pathlib.Path",
        "csv",
        "pandas",
        "utils.logger.logger",
        "utils.logger.log_error",
        "utils.error_handler.ErrorHandler",
        "utils.error_handler.check_database_connection",
        "utils.error_handler.DatabaseError",
        "config.TABLES",
        "config.COLORS",
        "store_management.config.get_database_path",
        "store_management.database.base.DatabaseManager"
      ],
      "classes": [
        {
          "name": "SupplierView",
          "docstring": "",
          "methods": [
            {
              "name": "handle_return",
              "docstring": "Handle Return key press",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "handle_escape",
              "docstring": "Handle Escape key press",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "show_search_dialog",
              "docstring": "Open dialog to search suppliers",
              "args": [
                "self"
              ]
            },
            {
              "name": "show_filter_dialog",
              "docstring": "Open dialog to filter suppliers",
              "args": [
                "self"
              ]
            },
            {
              "name": "save_table",
              "docstring": "Save the current table data to a file",
              "args": [
                "self"
              ]
            },
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "parent"
              ]
            },
            {
              "name": "setup_toolbar",
              "docstring": "Create the toolbar with all buttons",
              "args": [
                "self"
              ]
            },
            {
              "name": "setup_table",
              "docstring": "Create the main table view",
              "args": [
                "self"
              ]
            },
            {
              "name": "load_data",
              "docstring": "Load supplier data from the database and populate the treeview",
              "args": [
                "self"
              ]
            },
            {
              "name": "load_table",
              "docstring": "Alias for load_data method",
              "args": [
                "self"
              ]
            },
            {
              "name": "reset_view",
              "docstring": "Reset the view to show all suppliers",
              "args": [
                "self"
              ]
            },
            {
              "name": "show_add_dialog",
              "docstring": "Open dialog to add a new supplier",
              "args": [
                "self"
              ]
            },
            {
              "name": "delete_selected",
              "docstring": "Delete selected supplier(s)",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "on_double_click",
              "docstring": "Handle double-click event for editing",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "start_cell_edit",
              "docstring": "Start editing a cell",
              "args": [
                "self",
                "item",
                "column"
              ]
            },
            {
              "name": "undo",
              "docstring": "Undo last action",
              "args": [
                "self"
              ]
            },
            {
              "name": "redo",
              "docstring": "Redo last undone action",
              "args": [
                "self"
              ]
            },
            {
              "name": "sort_column",
              "docstring": "Sort tree contents when a column header is clicked",
              "args": [
                "self",
                "column"
              ]
            }
          ],
          "base_classes": [
            "ttk.Frame"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "gui\\order\\__init__.py": {
      "path": "gui\\order\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "gui\\product\\recipe_view.py": {
      "path": "gui\\product\\recipe_view.py",
      "imports": [
        "tkinter",
        "tkinter.ttk",
        "tkinter.messagebox",
        "sqlalchemy.exc.SQLAlchemyError",
        "sqlalchemy.or_",
        "typing.Optional",
        "datetime.datetime",
        "store_management.database.sqlalchemy.models.Recipe",
        "store_management.database.sqlalchemy.models.RecipeItem",
        "store_management.database.sqlalchemy.models.Part",
        "store_management.database.sqlalchemy.models.Leather",
        "store_management.database.sqlalchemy.manager.DatabaseManagerSQLAlchemy"
      ],
      "classes": [
        {
          "name": "RecipeView",
          "docstring": "",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "parent"
              ]
            },
            {
              "name": "create_ui",
              "docstring": "Create the user interface",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_toolbar",
              "docstring": "Create the toolbar with action buttons",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_main_content",
              "docstring": "Create both table views",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_treeview",
              "docstring": "Create a treeview with scrollbars",
              "args": [
                "self",
                "parent",
                "columns",
                "select_callback"
              ]
            },
            {
              "name": "create_status_bar",
              "docstring": "Create the status bar",
              "args": [
                "self"
              ]
            },
            {
              "name": "load_data",
              "docstring": "Load recipe data from database",
              "args": [
                "self"
              ]
            },
            {
              "name": "on_index_select",
              "docstring": "Handle selection in recipe index",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "load_recipe_details",
              "docstring": "Load details for selected recipe",
              "args": [
                "self",
                "recipe_id"
              ]
            },
            {
              "name": "show_add_recipe_dialog",
              "docstring": "Show dialog for adding new recipe",
              "args": [
                "self"
              ]
            },
            {
              "name": "show_add_item_dialog",
              "docstring": "Show dialog for adding item to recipe",
              "args": [
                "self"
              ]
            },
            {
              "name": "show_search_dialog",
              "docstring": "Show search dialog",
              "args": [
                "self"
              ]
            },
            {
              "name": "show_filter_dialog",
              "docstring": "Show filter dialog",
              "args": [
                "self"
              ]
            },
            {
              "name": "delete_selected",
              "docstring": "Delete selected items",
              "args": [
                "self",
                "tree"
              ]
            },
            {
              "name": "undo",
              "docstring": "Undo last action",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "redo",
              "docstring": "Redo last undone action",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "sort_column",
              "docstring": "Sort treeview column",
              "args": [
                "self",
                "tree",
                "col"
              ]
            }
          ],
          "base_classes": [
            "ttk.Frame"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "gui\\product\\storage_view.py": {
      "path": "gui\\product\\storage_view.py",
      "imports": [
        "tkinter",
        "tkinter.ttk",
        "tkinter.messagebox",
        "sqlalchemy.exc.SQLAlchemyError",
        "sqlalchemy.or_",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "uuid",
        "store_management.database.sqlalchemy.models.Storage",
        "store_management.database.sqlalchemy.models.Product",
        "store_management.database.sqlalchemy.models.Recipe",
        "store_management.database.sqlalchemy.manager.DatabaseManagerSQLAlchemy"
      ],
      "classes": [
        {
          "name": "StorageView",
          "docstring": "",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "parent"
              ]
            },
            {
              "name": "setup_toolbar",
              "docstring": "Create the toolbar with all buttons",
              "args": [
                "self"
              ]
            },
            {
              "name": "setup_table",
              "docstring": "Create the main table view",
              "args": [
                "self"
              ]
            },
            {
              "name": "load_data",
              "docstring": "Load storage data using SQLAlchemy",
              "args": [
                "self"
              ]
            },
            {
              "name": "show_add_dialog",
              "docstring": "Show dialog for adding new storage item",
              "args": [
                "self"
              ]
            },
            {
              "name": "show_search_dialog",
              "docstring": "Show search dialog",
              "args": [
                "self"
              ]
            },
            {
              "name": "show_filter_dialog",
              "docstring": "Show filter dialog",
              "args": [
                "self"
              ]
            },
            {
              "name": "delete_selected",
              "docstring": "Delete selected storage items",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "on_double_click",
              "docstring": "Handle double-click for cell editing",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "start_cell_edit",
              "docstring": "Start editing a cell",
              "args": [
                "self",
                "item",
                "column"
              ]
            },
            {
              "name": "undo",
              "docstring": "Undo last action",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "redo",
              "docstring": "Redo last undone action",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "reset_view",
              "docstring": "Reset view to default state",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "ttk.Frame"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "gui\\product\\__init__.py": {
      "path": "gui\\product\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "gui\\recipe\\recipe_view.py": {
      "path": "gui\\recipe\\recipe_view.py",
      "imports": [
        "tkinter",
        "tkinter.ttk",
        "tkinter.messagebox",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "datetime.datetime",
        "store_management.application.Application",
        "store_management.gui.base_view.BaseView",
        "store_management.services.interfaces.recipe_service.IRecipeService",
        "store_management.services.interfaces.inventory_service.IInventoryService"
      ],
      "classes": [
        {
          "name": "RecipeView",
          "docstring": "View for managing recipes with comprehensive functionality.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the recipe view.\n\nArgs:\n    parent: Parent widget\n    app: Application instance for dependency management",
              "args": [
                "self",
                "parent",
                "app"
              ]
            },
            {
              "name": "setup_ui",
              "docstring": "Set up the UI components for the recipe view.",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_toolbar",
              "docstring": "Create the toolbar with action buttons.",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_recipes_treeview",
              "docstring": "Create the treeview for displaying recipes.",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_details_view",
              "docstring": "Create the recipe details view.",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_info_view",
              "docstring": "Create the recipe info view.",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_items_view",
              "docstring": "Create the recipe items view.",
              "args": [
                "self"
              ]
            },
            {
              "name": "on_recipe_select",
              "docstring": "Handle recipe selection in treeview.",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "load_recipe_details",
              "docstring": "Load details for a specific recipe.\n\nArgs:\n    recipe_id: ID of the recipe to load",
              "args": [
                "self",
                "recipe_id"
              ]
            },
            {
              "name": "show_add_recipe_dialog",
              "docstring": "Show dialog for adding a new recipe.",
              "args": [
                "self"
              ]
            },
            {
              "name": "edit_recipe",
              "docstring": "Edit the selected recipe.",
              "args": [
                "self"
              ]
            },
            {
              "name": "delete_recipe",
              "docstring": "Delete the selected recipe.",
              "args": [
                "self"
              ]
            },
            {
              "name": "load_data",
              "docstring": "Load recipe data from service.",
              "args": [
                "self"
              ]
            },
            {
              "name": "cleanup",
              "docstring": "Perform cleanup when view is closed.",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "BaseView"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "gui\\recipe\\__init__.py": {
      "path": "gui\\recipe\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "gui\\reports\\report_manager.py": {
      "path": "gui\\reports\\report_manager.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "gui\\reports\\__init__.py": {
      "path": "gui\\reports\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "gui\\shopping_list\\shopping_list_view.py": {
      "path": "gui\\shopping_list\\shopping_list_view.py",
      "imports": [
        "tkinter",
        "tkinter.ttk",
        "tkinter.messagebox",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "datetime.datetime",
        "store_management.application.Application",
        "store_management.gui.base_view.BaseView",
        "store_management.services.interfaces.shopping_list_service.IShoppingListService"
      ],
      "classes": [
        {
          "name": "ShoppingListView",
          "docstring": "View for managing shopping lists",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the shopping list view.\n\nArgs:\n    parent: Parent widget\n    app: Application instance",
              "args": [
                "self",
                "parent",
                "app"
              ]
            },
            {
              "name": "setup_ui",
              "docstring": "Set up the UI components.",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_toolbar",
              "docstring": "Create the toolbar with action buttons.",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_lists_treeview",
              "docstring": "Create the treeview for displaying shopping lists.",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_details_view",
              "docstring": "Create the shopping list details view.",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_info_view",
              "docstring": "Create the shopping list info view.",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_items_view",
              "docstring": "Create the shopping list items view.",
              "args": [
                "self"
              ]
            },
            {
              "name": "load_data",
              "docstring": "Load shopping list data from service.",
              "args": [
                "self"
              ]
            },
            {
              "name": "on_list_select",
              "docstring": "Handle shopping list selection.\n\nArgs:\n    event: Tkinter event (optional)",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "load_list_details",
              "docstring": "Load details for a specific shopping list.\n\nArgs:\n    list_id: ID of the shopping list to load",
              "args": [
                "self",
                "list_id"
              ]
            },
            {
              "name": "show_add_list_dialog",
              "docstring": "Show dialog for creating a new shopping list.",
              "args": [
                "self"
              ]
            },
            {
              "name": "show_add_item_dialog",
              "docstring": "Show dialog for adding an item to the shopping list.",
              "args": [
                "self"
              ]
            },
            {
              "name": "show_mark_purchased_dialog",
              "docstring": "Show dialog for marking an item as purchased.",
              "args": [
                "self"
              ]
            },
            {
              "name": "remove_item",
              "docstring": "Remove selected item from the shopping list.",
              "args": [
                "self"
              ]
            },
            {
              "name": "delete_list",
              "docstring": "Delete the selected shopping list.",
              "args": [
                "self"
              ]
            },
            {
              "name": "show_search_dialog",
              "docstring": "Show search dialog for shopping lists.",
              "args": [
                "self"
              ]
            },
            {
              "name": "save",
              "docstring": "Save current view data.",
              "args": [
                "self"
              ]
            },
            {
              "name": "undo",
              "docstring": "Undo the last action.",
              "args": [
                "self"
              ]
            },
            {
              "name": "redo",
              "docstring": "Redo the last undone action.",
              "args": [
                "self"
              ]
            },
            {
              "name": "cleanup",
              "docstring": "Perform cleanup when view is closed.",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "BaseView"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "gui\\shopping_list\\__init__.py": {
      "path": "gui\\shopping_list\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "gui\\storage\\sorting_system_view.py": {
      "path": "gui\\storage\\sorting_system_view.py",
      "imports": [
        "tkinter",
        "tkinter.ttk",
        "tkinter.messagebox",
        "typing.Dict",
        "typing.List",
        "typing.Optional",
        "pandas",
        "sqlalchemy.select",
        "sqlalchemy.orm.joinedload",
        "store_management.database.sqlalchemy.session.SessionLocal",
        "store_management.database.sqlalchemy.models.Storage",
        "store_management.database.sqlalchemy.models.Product",
        "store_management.gui.dialogs.add_dialog.AddDialog",
        "store_management.gui.dialogs.search_dialog.SearchDialog",
        "store_management.gui.dialogs.filter_dialog.FilterDialog",
        "store_management.utils.error_handler.handle_error",
        "store_management.utils.logger.log_action"
      ],
      "classes": [
        {
          "name": "SortingSystemView",
          "docstring": "",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the Sorting System View with SQLAlchemy integration\n\nArgs:\n    parent (tk.Widget): Parent widget\n    session_factory (callable): SQLAlchemy session factory",
              "args": [
                "self",
                "parent",
                "session_factory"
              ]
            },
            {
              "name": "setup_toolbar",
              "docstring": "Create the toolbar with all buttons",
              "args": [
                "self"
              ]
            },
            {
              "name": "setup_table",
              "docstring": "Create the main table view",
              "args": [
                "self"
              ]
            },
            {
              "name": "load_data",
              "docstring": "Load data from database into table",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_warning_tag",
              "docstring": "Determine the warning level tag based on stock level\n\nArgs:\n    amount (int): Current stock level\n    warning_threshold (int): Warning threshold level\n\nReturns:\n    str: Warning tag level or empty string if no warning",
              "args": [
                "self",
                "amount",
                "warning_threshold"
              ]
            },
            {
              "name": "show_add_dialog",
              "docstring": "Show dialog for adding a new storage item",
              "args": [
                "self"
              ]
            },
            {
              "name": "save_new_item",
              "docstring": "Save a new storage item to the database\n\nArgs:\n    data (Dict): Dictionary of item data",
              "args": [
                "self",
                "data"
              ]
            },
            {
              "name": "generate_unique_id",
              "docstring": "Generate a unique product ID based on the name\n\nArgs:\n    name (str): Product name\n\nReturns:\n    str: Generated unique ID",
              "args": [
                "self",
                "name"
              ]
            },
            {
              "name": "on_double_click",
              "docstring": "Handle double-click event for cell editing\n\nArgs:\n    event (tk.Event): Tkinter event object",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "start_cell_edit",
              "docstring": "Start inline cell editing\n\nArgs:\n    item (str): Treeview item identifier\n    column (str): Column identifier",
              "args": [
                "self",
                "item",
                "column"
              ]
            },
            {
              "name": "delete_selected",
              "docstring": "Delete selected storage items",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "undo",
              "docstring": "Undo the last action",
              "args": [
                "self"
              ]
            },
            {
              "name": "redo",
              "docstring": "Redo the last undone action",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "ttk.Frame"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "gui\\storage\\storage_view.py": {
      "path": "gui\\storage\\storage_view.py",
      "imports": [
        "tkinter",
        "tkinter.ttk",
        "tkinter.messagebox",
        "typing.Optional",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "store_management.application.Application",
        "store_management.gui.base_view.BaseView",
        "store_management.services.interfaces.storage_service.IStorageService"
      ],
      "classes": [
        {
          "name": "StorageView",
          "docstring": "Storage view for managing storage locations.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the storage view.\n\nArgs:\n    parent: Parent widget\n    app: Application instance",
              "args": [
                "self",
                "parent",
                "app"
              ]
            },
            {
              "name": "setup_ui",
              "docstring": "Set up the UI components.",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_toolbar",
              "docstring": "Create the toolbar with action buttons.",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_treeview",
              "docstring": "Create the treeview for displaying storage locations.",
              "args": [
                "self"
              ]
            },
            {
              "name": "load_data",
              "docstring": "Load storage data from service.",
              "args": [
                "self"
              ]
            },
            {
              "name": "show_add_dialog",
              "docstring": "Show dialog for adding a new storage location.",
              "args": [
                "self"
              ]
            },
            {
              "name": "on_double_click",
              "docstring": "Handle double-click event for editing.",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "start_cell_edit",
              "docstring": "Start editing a cell.",
              "args": [
                "self",
                "item",
                "column"
              ]
            },
            {
              "name": "delete_selected",
              "docstring": "Delete selected storage locations.",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "show_search_dialog",
              "docstring": "Show search dialog.",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "BaseView"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "gui\\storage\\__init__.py": {
      "path": "gui\\storage\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "database\\interfaces\\base_repository.py": {
      "path": "database\\interfaces\\base_repository.py",
      "imports": [
        "typing.TypeVar",
        "typing.Generic",
        "typing.Optional",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "sqlalchemy.orm.Session",
        "models.base.Base"
      ],
      "classes": [
        {
          "name": "BaseRepository",
          "docstring": "Generic base repository implementing common database operations.\n\nType parameter T must be a SQLAlchemy model class.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the repository with a session and model class.\n\nArgs:\n    session: SQLAlchemy session\n    model_class: Model class this repository handles",
              "args": [
                "self",
                "session",
                "model_class"
              ]
            },
            {
              "name": "get",
              "docstring": "Get a single record by ID.\n\nArgs:\n    id: Primary key value\n\nReturns:\n    Model instance if found, None otherwise",
              "args": [
                "self",
                "id"
              ]
            },
            {
              "name": "get_all",
              "docstring": "Get all records.\n\nReturns:\n    List of all model instances",
              "args": [
                "self"
              ]
            },
            {
              "name": "create",
              "docstring": "Create a new record.\n\nArgs:\n    **kwargs: Model attributes\n\nReturns:\n    Created model instance",
              "args": [
                "self"
              ]
            },
            {
              "name": "update",
              "docstring": "Update a record by ID.\n\nArgs:\n    id: Primary key value\n    **kwargs: Attributes to update\n\nReturns:\n    Updated model instance or None if not found",
              "args": [
                "self",
                "id"
              ]
            },
            {
              "name": "delete",
              "docstring": "Delete a record by ID.\n\nArgs:\n    id: Primary key value\n\nReturns:\n    True if deleted, False if not found",
              "args": [
                "self",
                "id"
              ]
            },
            {
              "name": "filter_by",
              "docstring": "Get records matching the given criteria.\n\nArgs:\n    **kwargs: Filter criteria\n\nReturns:\n    List of matching model instances",
              "args": [
                "self"
              ]
            },
            {
              "name": "exists",
              "docstring": "Check if a record exists with the given criteria.\n\nArgs:\n    **kwargs: Filter criteria\n\nReturns:\n    True if exists, False otherwise",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": [
        "T"
      ]
    },
    "database\\interfaces\\__init__.py": {
      "path": "database\\interfaces\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "database\\models\\base.py": {
      "path": "database\\models\\base.py",
      "imports": [
        "sqlalchemy.orm.DeclarativeBase",
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.DateTime",
        "datetime.datetime"
      ],
      "classes": [
        {
          "name": "Base",
          "docstring": "Base declarative model for all database models.\nProvides common fields and behaviors.",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "Default string representation of the model.\n\nReturns:\n    String representation with class name and ID",
              "args": [
                "self"
              ]
            },
            {
              "name": "to_dict",
              "docstring": "Convert model instance to dictionary.\n\nReturns:\n    Dictionary representation of the model",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "DeclarativeBase"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\models\\enums.py": {
      "path": "database\\models\\enums.py",
      "imports": [
        "enum.Enum"
      ],
      "classes": [
        {
          "name": "InventoryStatus",
          "docstring": "",
          "methods": [],
          "base_classes": [
            "Enum"
          ]
        },
        {
          "name": "ProductionStatus",
          "docstring": "",
          "methods": [],
          "base_classes": [
            "Enum"
          ]
        },
        {
          "name": "TransactionType",
          "docstring": "",
          "methods": [],
          "base_classes": [
            "Enum"
          ]
        },
        {
          "name": "OrderStatus",
          "docstring": "",
          "methods": [],
          "base_classes": [
            "Enum"
          ]
        },
        {
          "name": "PaymentStatus",
          "docstring": "",
          "methods": [],
          "base_classes": [
            "Enum"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\models\\leather.py": {
      "path": "database\\models\\leather.py",
      "imports": [
        "datetime.datetime",
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.Float",
        "sqlalchemy.DateTime",
        "sqlalchemy.ForeignKey",
        "sqlalchemy.Enum",
        "sqlalchemy.orm.relationship",
        "base.Base",
        "enums.InventoryStatus"
      ],
      "classes": [
        {
          "name": "Leather",
          "docstring": "Leather model",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\models\\order.py": {
      "path": "database\\models\\order.py",
      "imports": [
        "datetime.datetime",
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.Float",
        "sqlalchemy.DateTime",
        "sqlalchemy.ForeignKey",
        "sqlalchemy.Enum",
        "sqlalchemy.orm.relationship",
        "base.Base",
        "enums.OrderStatus",
        "enums.PaymentStatus"
      ],
      "classes": [
        {
          "name": "Order",
          "docstring": "Purchase order model",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        },
        {
          "name": "OrderItem",
          "docstring": "Items in a purchase order",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\models\\part.py": {
      "path": "database\\models\\part.py",
      "imports": [
        "datetime.datetime",
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.Float",
        "sqlalchemy.DateTime",
        "sqlalchemy.ForeignKey",
        "sqlalchemy.Enum",
        "sqlalchemy.orm.relationship",
        "base.Base",
        "enums.InventoryStatus"
      ],
      "classes": [
        {
          "name": "Part",
          "docstring": "Part model",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\models\\product.py": {
      "path": "database\\models\\product.py",
      "imports": [
        "sqlalchemy.Column",
        "sqlalchemy.String",
        "sqlalchemy.Float",
        "sqlalchemy.ForeignKey",
        "sqlalchemy.orm.relationship",
        "base.Base"
      ],
      "classes": [
        {
          "name": "Product",
          "docstring": "Product model representing items that can be stored in storage locations.",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "String representation of the Product.\n\nReturns:\n    String with product name and ID",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\models\\recipe.py": {
      "path": "database\\models\\recipe.py",
      "imports": [
        "datetime.datetime",
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.Float",
        "sqlalchemy.DateTime",
        "sqlalchemy.ForeignKey",
        "sqlalchemy.orm.relationship",
        "base.Base"
      ],
      "classes": [
        {
          "name": "Recipe",
          "docstring": "Recipe model for manufacturing products",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        },
        {
          "name": "RecipeItem",
          "docstring": "Items required for a recipe",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\models\\shopping_list.py": {
      "path": "database\\models\\shopping_list.py",
      "imports": [
        "datetime.datetime",
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.Float",
        "sqlalchemy.DateTime",
        "sqlalchemy.ForeignKey",
        "sqlalchemy.Boolean",
        "sqlalchemy.orm.relationship",
        "base.Base"
      ],
      "classes": [
        {
          "name": "ShoppingList",
          "docstring": "Shopping list model",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        },
        {
          "name": "ShoppingListItem",
          "docstring": "Shopping list item model",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\models\\storage.py": {
      "path": "database\\models\\storage.py",
      "imports": [
        "sqlalchemy.Column",
        "sqlalchemy.String",
        "sqlalchemy.Float",
        "sqlalchemy.Integer",
        "sqlalchemy.orm.relationship",
        "store_management.database.sqlalchemy.base.Base"
      ],
      "classes": [
        {
          "name": "Storage",
          "docstring": "Storage model representing locations where products can be stored.\n\nAttributes:\n    id (int): Unique identifier for the storage location.\n    location (str): Specific location identifier.\n    description (str, optional): Description of the storage location.\n    capacity (float, optional): Total capacity of the storage location.\n    current_usage (float, optional): Current usage of the storage location.",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "String representation of the Storage instance.\n\nReturns:\n    str: Representation of the storage location with ID and location.",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\models\\supplier.py": {
      "path": "database\\models\\supplier.py",
      "imports": [
        "datetime.datetime",
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.Float",
        "sqlalchemy.DateTime",
        "sqlalchemy.orm.relationship",
        "base.Base"
      ],
      "classes": [
        {
          "name": "Supplier",
          "docstring": "Supplier model",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\models\\transaction.py": {
      "path": "database\\models\\transaction.py",
      "imports": [
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.Float",
        "sqlalchemy.DateTime",
        "sqlalchemy.ForeignKey",
        "sqlalchemy.Enum",
        "sqlalchemy.Boolean",
        "sqlalchemy.orm.relationship",
        "datetime.datetime",
        "store_management.database.sqlalchemy.base.Base",
        "store_management.database.sqlalchemy.models.enums.TransactionType"
      ],
      "classes": [
        {
          "name": "InventoryTransaction",
          "docstring": "Transaction model for tracking part inventory changes.\n\nAttributes:\n    id (int): Unique identifier for the transaction\n    part_id (int): Foreign key to the part involved\n    quantity_change (float): Change in quantity (positive or negative)\n    transaction_type (TransactionType): Type of transaction\n    notes (str): Additional notes about the transaction\n    created_at (datetime): Timestamp of transaction creation",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        },
        {
          "name": "LeatherTransaction",
          "docstring": "Transaction model for tracking leather inventory changes.\n\nAttributes:\n    id (int): Unique identifier for the transaction\n    leather_id (int): Foreign key to the leather involved\n    area_change (float): Change in area (positive or negative)\n    transaction_type (TransactionType): Type of transaction\n    notes (str): Additional notes about the transaction\n    wastage (float): Area lost during transaction\n    created_at (datetime): Timestamp of transaction creation",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\models\\__init__.py": {
      "path": "database\\models\\__init__.py",
      "imports": [
        "base.Base",
        "enums.InventoryStatus",
        "enums.ProductionStatus",
        "enums.TransactionType",
        "enums.OrderStatus",
        "enums.PaymentStatus",
        "part.Part",
        "storage.Storage",
        "product.Product",
        "order.Order",
        "order.OrderItem",
        "supplier.Supplier",
        "recipe.Recipe",
        "recipe.RecipeItem",
        "shopping_list.ShoppingList",
        "shopping_list.ShoppingListItem",
        "leather.Leather",
        "transaction.InventoryTransaction",
        "transaction.LeatherTransaction"
      ],
      "classes": [],
      "functions": [],
      "global_variables": [
        "__all__"
      ]
    },
    "database\\repositories\\leather_repository.py": {
      "path": "database\\repositories\\leather_repository.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "sqlalchemy.orm.Session",
        "sqlalchemy.orm.joinedload",
        "interfaces.base_repository.BaseRepository",
        "models.leather.Leather",
        "models.enums.InventoryStatus"
      ],
      "classes": [
        {
          "name": "LeatherRepository",
          "docstring": "Repository for Leather model operations",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "session"
              ]
            },
            {
              "name": "get_low_stock",
              "docstring": "Get leathers with low stock levels.\n\nReturns:\n    List of leathers with low stock",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_by_supplier",
              "docstring": "Get leathers by supplier.\n\nArgs:\n    supplier_id: Supplier ID\n\nReturns:\n    List of leathers from the specified supplier",
              "args": [
                "self",
                "supplier_id"
              ]
            },
            {
              "name": "get_with_transactions",
              "docstring": "Get leather with transaction history.\n\nArgs:\n    leather_id: Leather ID\n\nReturns:\n    Leather with loaded transactions or None",
              "args": [
                "self",
                "leather_id"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\repositories\\order_repository.py": {
      "path": "database\\repositories\\order_repository.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "datetime.datetime",
        "sqlalchemy.orm.Session",
        "sqlalchemy.orm.joinedload",
        "interfaces.base_repository.BaseRepository",
        "models.order.Order",
        "models.order.OrderItem",
        "models.enums.OrderStatus"
      ],
      "classes": [
        {
          "name": "OrderRepository",
          "docstring": "Repository for Order model operations",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "session"
              ]
            },
            {
              "name": "get_with_items",
              "docstring": "Get order with all items.\n\nArgs:\n    order_id: Order ID\n\nReturns:\n    Order with loaded items or None",
              "args": [
                "self",
                "order_id"
              ]
            },
            {
              "name": "get_by_status",
              "docstring": "Get orders by status.\n\nArgs:\n    status: Order status\n\nReturns:\n    List of orders with the specified status",
              "args": [
                "self",
                "status"
              ]
            },
            {
              "name": "get_by_date_range",
              "docstring": "Get orders within a date range.\n\nArgs:\n    start_date: Start date\n    end_date: End date\n\nReturns:\n    List of orders within the date range",
              "args": [
                "self",
                "start_date",
                "end_date"
              ]
            },
            {
              "name": "get_by_supplier",
              "docstring": "Get orders for a supplier.\n\nArgs:\n    supplier_id: Supplier ID\n\nReturns:\n    List of orders for the supplier",
              "args": [
                "self",
                "supplier_id"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\repositories\\part_repository.py": {
      "path": "database\\repositories\\part_repository.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "sqlalchemy.orm.Session",
        "sqlalchemy.orm.joinedload",
        "interfaces.base_repository.BaseRepository",
        "models.part.Part",
        "models.enums.InventoryStatus"
      ],
      "classes": [
        {
          "name": "PartRepository",
          "docstring": "Repository for Part model operations",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "session"
              ]
            },
            {
              "name": "get_low_stock",
              "docstring": "Get parts with low stock levels.\n\nReturns:\n    List of parts with low stock",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_by_supplier",
              "docstring": "Get parts by supplier.\n\nArgs:\n    supplier_id: Supplier ID\n\nReturns:\n    List of parts from the specified supplier",
              "args": [
                "self",
                "supplier_id"
              ]
            },
            {
              "name": "get_with_transactions",
              "docstring": "Get part with transaction history.\n\nArgs:\n    part_id: Part ID\n\nReturns:\n    Part with loaded transactions or None",
              "args": [
                "self",
                "part_id"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\repositories\\product_repository.py": {
      "path": "database\\repositories\\product_repository.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "sqlalchemy.orm.Session",
        "interfaces.base_repository.BaseRepository",
        "models.product.Product"
      ],
      "classes": [
        {
          "name": "ProductRepository",
          "docstring": "Repository for Product model operations",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "session"
              ]
            },
            {
              "name": "get_by_storage",
              "docstring": "Get products by storage location.\n\nArgs:\n    storage_id: Storage location ID\n\nReturns:\n    List of products in the specified storage",
              "args": [
                "self",
                "storage_id"
              ]
            },
            {
              "name": "search_by_name",
              "docstring": "Search products by name.\n\nArgs:\n    name: Product name to search for\n\nReturns:\n    List of matching products",
              "args": [
                "self",
                "name"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\repositories\\recipe_repository.py": {
      "path": "database\\repositories\\recipe_repository.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Tuple",
        "sqlalchemy.orm.Session",
        "sqlalchemy.orm.joinedload",
        "interfaces.base_repository.BaseRepository",
        "models.recipe.Recipe",
        "models.recipe.RecipeItem"
      ],
      "classes": [
        {
          "name": "RecipeRepository",
          "docstring": "Repository for Recipe model operations",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "session"
              ]
            },
            {
              "name": "get_with_items",
              "docstring": "Get recipe with all items.\n\nArgs:\n    recipe_id: Recipe ID\n\nReturns:\n    Recipe with loaded items or None",
              "args": [
                "self",
                "recipe_id"
              ]
            },
            {
              "name": "get_by_product",
              "docstring": "Get recipes for a product.\n\nArgs:\n    product_id: Product ID\n\nReturns:\n    List of recipes for the product",
              "args": [
                "self",
                "product_id"
              ]
            },
            {
              "name": "get_recipe_item",
              "docstring": "Get a specific recipe item.\n\nArgs:\n    item_id: Recipe item ID\n\nReturns:\n    Recipe item or None",
              "args": [
                "self",
                "item_id"
              ]
            },
            {
              "name": "add_recipe_item",
              "docstring": "Add an item to a recipe.\n\nArgs:\n    recipe_id: Recipe ID\n    item_data: Item data\n\nReturns:\n    Created recipe item",
              "args": [
                "self",
                "recipe_id",
                "item_data"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\repositories\\shopping_list_repository.py": {
      "path": "database\\repositories\\shopping_list_repository.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "sqlalchemy.orm.Session",
        "sqlalchemy.orm.joinedload",
        "interfaces.base_repository.BaseRepository",
        "models.shopping_list.ShoppingList",
        "models.shopping_list.ShoppingListItem"
      ],
      "classes": [
        {
          "name": "ShoppingListRepository",
          "docstring": "Repository for ShoppingList model operations",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "session"
              ]
            },
            {
              "name": "get_with_items",
              "docstring": "Get shopping list with all items.\n\nArgs:\n    list_id: Shopping list ID\n\nReturns:\n    Shopping list with loaded items or None",
              "args": [
                "self",
                "list_id"
              ]
            },
            {
              "name": "get_pending_items",
              "docstring": "Get all unpurchased shopping list items.\n\nReturns:\n    List of unpurchased shopping list items",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_items_by_supplier",
              "docstring": "Get shopping list items for a supplier.\n\nThis is more complex as it needs to join through the part or leather\nto find items for a supplier.\n\nArgs:\n    supplier_id: Supplier ID\n\nReturns:\n    List of shopping list items for the supplier",
              "args": [
                "self",
                "supplier_id"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\repositories\\storage_repository.py": {
      "path": "database\\repositories\\storage_repository.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "sqlalchemy.orm.Session",
        "sqlalchemy.select",
        "store_management.database.sqlalchemy.base_manager.BaseManager",
        "store_management.database.sqlalchemy.models.storage.Storage",
        "store_management.database.sqlalchemy.manager_factory.register_specialized_manager"
      ],
      "classes": [
        {
          "name": "StorageRepository",
          "docstring": "Specialized repository for Storage model with additional methods.\n\nProvides storage-specific operations beyond standard CRUD methods.",
          "methods": [
            {
              "name": "get_by_location",
              "docstring": "Retrieve a storage location by its specific location.\n\nArgs:\n    location: The location identifier\n\nReturns:\n    Storage instance if found, None otherwise",
              "args": [
                "self",
                "location"
              ]
            },
            {
              "name": "get_available_storage",
              "docstring": "Retrieve all available storage locations.\n\nReturns:\n    List of available storage locations",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_storage_with_details",
              "docstring": "Get detailed information about a storage location.\n\nArgs:\n    storage_id: ID of the storage location\n\nReturns:\n    Dictionary with storage details, or None if not found",
              "args": [
                "self",
                "storage_id"
              ]
            },
            {
              "name": "search_storage",
              "docstring": "Search storage locations by location or description.\n\nArgs:\n    search_term: Term to search for\n\nReturns:\n    List of matching storage locations",
              "args": [
                "self",
                "search_term"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [
        {
          "name": "get_storage_repository",
          "docstring": "Backward-compatible method to get a storage repository.\n\nArgs:\n    session: Optional SQLAlchemy session (for backward compatibility)\n\nReturns:\n    StorageRepository instance",
          "args": [
            "session"
          ]
        }
      ],
      "global_variables": []
    },
    "database\\repositories\\supplier_repository.py": {
      "path": "database\\repositories\\supplier_repository.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "sqlalchemy.orm.Session",
        "sqlalchemy.orm.joinedload",
        "interfaces.base_repository.BaseRepository",
        "models.supplier.Supplier"
      ],
      "classes": [
        {
          "name": "SupplierRepository",
          "docstring": "Repository for Supplier model operations",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "session"
              ]
            },
            {
              "name": "get_with_products",
              "docstring": "Get supplier with eagerly loaded products.\n\nArgs:\n    supplier_id: Supplier ID\n\nReturns:\n    Supplier with products if found, None otherwise",
              "args": [
                "self",
                "supplier_id"
              ]
            },
            {
              "name": "search",
              "docstring": "Search suppliers by name or contact name.\n\nArgs:\n    term: Search term\n\nReturns:\n    List of matching suppliers",
              "args": [
                "self",
                "term"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\repositories\\__init__.py": {
      "path": "database\\repositories\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "database\\scripts\\run_migration.py": {
      "path": "database\\scripts\\run_migration.py",
      "imports": [
        "sqlalchemy.create_engine",
        "store_management.database.sqlalchemy.models.Base",
        "store_management.database.sqlalchemy.session.DATABASE_URL"
      ],
      "classes": [],
      "functions": [
        {
          "name": "initialize_database",
          "docstring": "Initialize the database with all tables.",
          "args": []
        }
      ],
      "global_variables": []
    },
    "database\\scripts\\__init__.py": {
      "path": "database\\scripts\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\base.py": {
      "path": "database\\sqlalchemy\\base.py",
      "imports": [
        "sqlalchemy.orm.declarative_base"
      ],
      "classes": [],
      "functions": [],
      "global_variables": [
        "Base"
      ]
    },
    "database\\sqlalchemy\\base_manager.py": {
      "path": "database\\sqlalchemy\\base_manager.py",
      "imports": [
        "sqlalchemy.create_engine",
        "sqlalchemy.orm.sessionmaker",
        "sqlalchemy.orm.Session",
        "store_management.database.sqlalchemy.base.Base"
      ],
      "classes": [
        {
          "name": "BaseManager",
          "docstring": "Base class for database operations providing common functionality.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the manager with a database connection.\n\nArgs:\n    connection_string: Database connection string",
              "args": [
                "self",
                "connection_string"
              ]
            },
            {
              "name": "create_tables",
              "docstring": "Create all tables defined in model classes",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_session",
              "docstring": "Get a new database session.\n\nReturns:\n    Session object to interact with the database",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\config.py": {
      "path": "database\\sqlalchemy\\config.py",
      "imports": [
        "os",
        "typing.Dict",
        "typing.Any",
        "sqlalchemy.create_engine",
        "sqlalchemy.text",
        "sqlalchemy.orm.sessionmaker",
        "sqlalchemy.orm.scoped_session",
        "sqlalchemy.orm.Session",
        "sqlalchemy_utils.database_exists",
        "sqlalchemy_utils.create_database",
        "pathlib.Path"
      ],
      "classes": [
        {
          "name": "DatabaseConfig",
          "docstring": "Centralized database configuration management with singleton pattern",
          "methods": [
            {
              "name": "__new__",
              "docstring": "",
              "args": [
                "cls"
              ]
            },
            {
              "name": "_initialize",
              "docstring": "Initialize database configuration with comprehensive setup",
              "args": [
                "self"
              ]
            },
            {
              "name": "_find_project_root",
              "docstring": "Dynamically find the project root directory\n\nReturns:\n    Path: Project root directory",
              "args": [
                "self"
              ]
            },
            {
              "name": "_load_config",
              "docstring": "Load database configuration with environment variable precedence\n\nReturns:\n    Dict[str, Any]: Configured database settings",
              "args": [
                "self"
              ]
            },
            {
              "name": "_get_database_url",
              "docstring": "Generate database URL based on configuration\n\nReturns:\n    str: Fully qualified database connection URL",
              "args": [
                "self"
              ]
            },
            {
              "name": "_create_engine",
              "docstring": "Create SQLAlchemy engine with comprehensive configuration\n\nReturns:\n    Engine: Configured SQLAlchemy engine",
              "args": [
                "self"
              ]
            },
            {
              "name": "_create_session_factory",
              "docstring": "Create thread-local scoped session factory\n\nReturns:\n    scoped_session: Configured session factory",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_session",
              "docstring": "Get a database session\n\nReturns:\n    Session: Active database session",
              "args": [
                "self"
              ]
            },
            {
              "name": "close_session",
              "docstring": "Close all sessions and remove session factory",
              "args": [
                "self"
              ]
            },
            {
              "name": "test_connection",
              "docstring": "Test database connection\n\nReturns:\n    bool: True if connection successful, False otherwise",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_database_url",
              "docstring": "Public method to retrieve database URL\n\nReturns:\n    str: Database connection URL",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [
        {
          "name": "get_database_url",
          "docstring": "Function to get the database URL for direct import\n\nReturns:\n    str: Database connection URL",
          "args": []
        },
        {
          "name": "get_database_path",
          "docstring": "Get the absolute path to the database file\n\nReturns:\n    Path: Absolute path to the database file",
          "args": []
        }
      ],
      "global_variables": [
        "database_config",
        "__all__"
      ]
    },
    "database\\sqlalchemy\\manager.py": {
      "path": "database\\sqlalchemy\\manager.py",
      "imports": [
        "sqlalchemy.orm.Session",
        "sqlalchemy.create_engine",
        "sqlalchemy.inspect",
        "sqlalchemy.exc.SQLAlchemyError",
        "contextlib.contextmanager",
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Type",
        "typing.Union",
        "datetime.datetime",
        "store_management.database.sqlalchemy.models.base.Base",
        "store_management.database.sqlalchemy.models"
      ],
      "classes": [
        {
          "name": "DatabaseError",
          "docstring": "Custom database error for SQLAlchemy operations",
          "methods": [],
          "base_classes": [
            "Exception"
          ]
        },
        {
          "name": "BaseManager",
          "docstring": "Base manager class with common session and logging methods",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize base manager with session factory\n\nArgs:\n    session_factory: SQLAlchemy session factory",
              "args": [
                "self",
                "session_factory"
              ]
            },
            {
              "name": "session_scope",
              "docstring": "Provide a transactional scope around a series of operations\n\nYields:\n    SQLAlchemy Session",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": []
        },
        {
          "name": "DatabaseManagerSQLAlchemy",
          "docstring": "Comprehensive database manager using SQLAlchemy ORM",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize database manager with database URL\n\nArgs:\n    database_url (str): SQLAlchemy database connection URL",
              "args": [
                "self",
                "database_url"
              ]
            },
            {
              "name": "session",
              "docstring": "Get current session or create a new one\n\nReturns:\n    SQLAlchemy Session",
              "args": [
                "self"
              ]
            },
            {
              "name": "session_scope",
              "docstring": "Provide a transactional scope around a series of operations\n\nYields:\n    SQLAlchemy Session",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_model_columns",
              "docstring": "Get column names for a specific model\n\nArgs:\n    model (Type[models.Base]): SQLAlchemy model class\n\nReturns:\n    List of column names",
              "args": [
                "self",
                "model"
              ]
            },
            {
              "name": "add_record",
              "docstring": "Add a new record to the database\n\nArgs:\n    model (Type[models.Base]): Model class\n    data (Dict[str, Any]): Record data\n\nReturns:\n    Newly created record or None",
              "args": [
                "self",
                "model",
                "data"
              ]
            },
            {
              "name": "update_record",
              "docstring": "Update an existing record\n\nArgs:\n    model (Type[Base]): Model class\n    record_id (int): Record ID\n    data (Dict[str, Any]): Updated data\n\nReturns:\n    Updated record or None",
              "args": [
                "self",
                "model",
                "record_id",
                "data"
              ]
            },
            {
              "name": "delete_record",
              "docstring": "Delete a record from the database\n\nArgs:\n    model (Type[Base]): Model class\n    record_id (int): Record ID\n\nReturns:\n    Boolean indicating success",
              "args": [
                "self",
                "model",
                "record_id"
              ]
            },
            {
              "name": "get_record",
              "docstring": "Get a single record by ID\n\nArgs:\n    model (Type[Base]): Model class\n    record_id (int): Record ID\n\nReturns:\n    Record or None",
              "args": [
                "self",
                "model",
                "record_id"
              ]
            },
            {
              "name": "get_all_records",
              "docstring": "Get all records of a model, optionally filtered\n\nArgs:\n    model (Type[Base]): Model class\n    **filters: Optional filter conditions\n\nReturns:\n    List of records",
              "args": [
                "self",
                "model"
              ]
            },
            {
              "name": "search_records",
              "docstring": "Search for records across specified fields\n\nArgs:\n    model (Type[Base]): Model class\n    search_term (str): Term to search for\n    *fields: Fields to search in\n\nReturns:\n    List of matching records",
              "args": [
                "self",
                "model",
                "search_term"
              ]
            },
            {
              "name": "bulk_update",
              "docstring": "Perform bulk updates on records\n\nArgs:\n    model (Type[Base]): Model class\n    updates (List[Dict]): List of update dictionaries\n\nReturns:\n    Boolean indicating success",
              "args": [
                "self",
                "model",
                "updates"
              ]
            },
            {
              "name": "execute_query",
              "docstring": "Execute a raw SQL query\n\nArgs:\n    query (str): SQL query string\n    params (Optional[tuple]): Query parameters\n\nReturns:\n    List of query results",
              "args": [
                "self",
                "query",
                "params"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\manager_factory.py": {
      "path": "database\\sqlalchemy\\manager_factory.py",
      "imports": [
        "typing.Type",
        "typing.Dict",
        "typing.Any",
        "typing.TypeVar",
        "typing.Optional",
        "typing.Callable",
        "typing.Union",
        "typing.List",
        "sqlalchemy.orm.Session",
        "store_management.database.sqlalchemy.base_manager.BaseManager",
        "store_management.database.session.get_db_session"
      ],
      "classes": [],
      "functions": [
        {
          "name": "register_specialized_manager",
          "docstring": "Register a specialized manager for a specific model class.\n\nArgs:\n    model_class: The SQLAlchemy model class\n    manager_class: The specialized manager class to use for this model",
          "args": [
            "model_class",
            "manager_class"
          ]
        },
        {
          "name": "get_manager",
          "docstring": "Get or create a manager for the specified model class.\n\nThis factory ensures only one manager is created per model class,\nwith support for specialized managers and optional mixins.\n\nArgs:\n    model_class: The SQLAlchemy model class\n    session_factory: Optional custom session factory (defaults to get_db_session)\n    mixins: Optional list of additional mixins to apply\n    force_new: If True, create a new manager instance\n\nReturns:\n    A BaseManager instance for the model class",
          "args": [
            "model_class",
            "session_factory",
            "mixins",
            "force_new"
          ]
        },
        {
          "name": "_create_manager",
          "docstring": "Create a new manager instance.\n\nArgs:\n    model_class: The SQLAlchemy model class\n    session_factory: Function to create database sessions\n    mixins: Optional list of mixins to apply\n\nReturns:\n    A BaseManager instance for the model class",
          "args": [
            "model_class",
            "session_factory",
            "mixins"
          ]
        },
        {
          "name": "clear_manager_cache",
          "docstring": "Clear the manager instance cache.\n\nUseful for testing or resetting the application state.",
          "args": []
        }
      ],
      "global_variables": [
        "T",
        "_manager_cache",
        "_specialized_managers"
      ]
    },
    "database\\sqlalchemy\\migration.py": {
      "path": "database\\sqlalchemy\\migration.py",
      "imports": [
        "os",
        "sys",
        "logging",
        "datetime.datetime",
        "typing.Optional",
        "sqlalchemy.create_engine",
        "sqlalchemy.inspect",
        "sqlalchemy.orm.sessionmaker",
        "store_management.database.sqlalchemy.models.Base"
      ],
      "classes": [
        {
          "name": "DatabaseInitializer",
          "docstring": "Comprehensive database initialization and migration utility",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize database initialization process\n\nArgs:\n    db_url (str): SQLAlchemy database URL\n    backup_dir (str, optional): Directory for database backups",
              "args": [
                "self",
                "db_url",
                "backup_dir"
              ]
            },
            {
              "name": "create_backup",
              "docstring": "Create a backup of the existing database if it exists\n\nReturns:\n    Optional[str]: Path to the backup file, or None if no backup created",
              "args": [
                "self"
              ]
            },
            {
              "name": "drop_all_tables",
              "docstring": "Drop all existing tables in the database",
              "args": [
                "self"
              ]
            },
            {
              "name": "initialize_database",
              "docstring": "Complete database initialization process\n\n1. Create backup of existing database\n2. Drop all existing tables\n3. Create new tables based on current model definitions",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [
        {
          "name": "run_database_initialization",
          "docstring": "Execute database initialization\n\nArgs:\n    db_url (str, optional): SQLAlchemy database URL\n    backup_dir (str, optional): Directory for database backups\n    force (bool, optional): Force initialization even if database exists\n\nReturns:\n    bool: Initialization success status",
          "args": [
            "db_url",
            "backup_dir",
            "force"
          ]
        }
      ],
      "global_variables": [
        "project_root",
        "logger"
      ]
    },
    "database\\sqlalchemy\\models.py": {
      "path": "database\\sqlalchemy\\models.py",
      "imports": [
        "enum.Enum",
        "enum.auto"
      ],
      "classes": [
        {
          "name": "InventoryStatus",
          "docstring": "Inventory status for parts and materials.",
          "methods": [],
          "base_classes": [
            "Enum"
          ]
        },
        {
          "name": "OrderStatus",
          "docstring": "Order processing status.",
          "methods": [],
          "base_classes": [
            "Enum"
          ]
        },
        {
          "name": "PaymentStatus",
          "docstring": "Payment processing status.",
          "methods": [],
          "base_classes": [
            "Enum"
          ]
        },
        {
          "name": "TransactionType",
          "docstring": "Types of inventory transactions.",
          "methods": [],
          "base_classes": [
            "Enum"
          ]
        },
        {
          "name": "ProductionStatus",
          "docstring": "Status of production processes.",
          "methods": [],
          "base_classes": [
            "Enum"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\model_utils.py": {
      "path": "database\\sqlalchemy\\model_utils.py",
      "imports": [],
      "classes": [],
      "functions": [
        {
          "name": "get_model_classes",
          "docstring": "Dynamically import and return a dictionary of model classes.\n\nReturns:\n    Dict of model names to their corresponding classes",
          "args": []
        }
      ],
      "global_variables": []
    },
    "database\\sqlalchemy\\session.py": {
      "path": "database\\sqlalchemy\\session.py",
      "imports": [
        "os",
        "contextlib.contextmanager",
        "typing.Optional",
        "sqlalchemy.create_engine",
        "sqlalchemy.orm.sessionmaker",
        "sqlalchemy.orm.scoped_session",
        "sqlalchemy.pool.NullPool",
        "sqlalchemy_utils.database_exists",
        "sqlalchemy_utils.create_database",
        "store_management.database.sqlalchemy.base.Base",
        "store_management.utils.error_handling.DatabaseError"
      ],
      "classes": [],
      "functions": [
        {
          "name": "init_database",
          "docstring": "Initialize the database, creating it if it doesn't exist.\n\nArgs:\n    db_url: Optional database URL (uses default if not provided)\n\nRaises:\n    DatabaseError: If database initialization fails",
          "args": [
            "db_url"
          ]
        },
        {
          "name": "get_db_session",
          "docstring": "Context manager for database sessions.\n\nProvides a transactional scope for database operations.\nAutomatically handles session creation, commit, and rollback.\n\nYields:\n    SQLAlchemy session object\n\nRaises:\n    DatabaseError: If session management fails",
          "args": []
        },
        {
          "name": "close_all_sessions",
          "docstring": "Close all active database sessions.\n\nUseful for cleanup and testing.",
          "args": []
        }
      ],
      "global_variables": [
        "DEFAULT_DATABASE_URL",
        "DATABASE_URL",
        "engine",
        "session_factory"
      ]
    },
    "database\\sqlalchemy\\__init__.py": {
      "path": "database\\sqlalchemy\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": [
        "__all__"
      ]
    },
    "database\\sqlalchemy\\core\\base_manager.py": {
      "path": "database\\sqlalchemy\\core\\base_manager.py",
      "imports": [
        "typing.Type",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "typing.TypeVar",
        "typing.Generic",
        "typing.Union",
        "typing.Callable",
        "logging",
        "contextlib.contextmanager",
        "sqlalchemy.orm.Session",
        "sqlalchemy.select",
        "sqlalchemy.inspect",
        "sqlalchemy.and_",
        "sqlalchemy.or_",
        "sqlalchemy.func",
        "sqlalchemy.exc.SQLAlchemyError",
        "store_management.utils.error_handling.DatabaseError"
      ],
      "classes": [
        {
          "name": "BaseManager",
          "docstring": "Comprehensive base manager for database operations.\n\nProvides a generic, type-safe implementation of common database operations\nwith extensive error handling and transaction management.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the base manager with a model class and session factory.\n\nArgs:\n    model_class: The SQLAlchemy model class this manager operates on\n    session_factory: A callable that returns a database session",
              "args": [
                "self",
                "model_class",
                "session_factory"
              ]
            },
            {
              "name": "session_scope",
              "docstring": "Provide a transactional scope around a series of operations.\n\nYields:\n    Session: Active database session\n\nRaises:\n    DatabaseError: If session management fails",
              "args": [
                "self"
              ]
            },
            {
              "name": "create",
              "docstring": "Create a new record in the database.\n\nArgs:\n    data: Dictionary of attributes for the new record\n\nReturns:\n    The created record\n\nRaises:\n    DatabaseError: If creation fails",
              "args": [
                "self",
                "data"
              ]
            },
            {
              "name": "get",
              "docstring": "Retrieve a record by its primary key.\n\nArgs:\n    id: Primary key value\n\nReturns:\n    The record if found, None otherwise\n\nRaises:\n    DatabaseError: If retrieval fails",
              "args": [
                "self",
                "id"
              ]
            },
            {
              "name": "get_all",
              "docstring": "Retrieve all records, with optional ordering and limit.\n\nArgs:\n    order_by: Optional column to order by\n    limit: Optional maximum number of records to return\n\nReturns:\n    List of records\n\nRaises:\n    DatabaseError: If retrieval fails",
              "args": [
                "self",
                "order_by",
                "limit"
              ]
            },
            {
              "name": "update",
              "docstring": "Update an existing record.\n\nArgs:\n    id: Primary key of the record to update\n    data: Dictionary of attributes to update\n\nReturns:\n    The updated record, or None if not found\n\nRaises:\n    DatabaseError: If update fails",
              "args": [
                "self",
                "id",
                "data"
              ]
            },
            {
              "name": "delete",
              "docstring": "Delete a record by its primary key.\n\nArgs:\n    id: Primary key of the record to delete\n\nReturns:\n    True if deletion was successful, False if record not found\n\nRaises:\n    DatabaseError: If deletion fails",
              "args": [
                "self",
                "id"
              ]
            },
            {
              "name": "exists",
              "docstring": "Check if a record exists with the given criteria.\n\nArgs:\n    **kwargs: Filter criteria\n\nReturns:\n    True if a matching record exists, False otherwise\n\nRaises:\n    DatabaseError: If check fails",
              "args": [
                "self"
              ]
            },
            {
              "name": "count",
              "docstring": "Count records matching the given criteria.\n\nArgs:\n    **kwargs: Filter criteria\n\nReturns:\n    Count of matching records\n\nRaises:\n    DatabaseError: If count fails",
              "args": [
                "self"
              ]
            },
            {
              "name": "filter_by",
              "docstring": "Retrieve records matching the given criteria.\n\nArgs:\n    **kwargs: Filter criteria\n\nReturns:\n    List of matching records\n\nRaises:\n    DatabaseError: If filtering fails",
              "args": [
                "self"
              ]
            },
            {
              "name": "search",
              "docstring": "Search for records where any of the specified fields contain the search term.\n\nArgs:\n    term: Search term\n    fields: List of fields to search in (if None, searches all string fields)\n\nReturns:\n    List of matching records\n\nRaises:\n    DatabaseError: If search fails",
              "args": [
                "self",
                "term",
                "fields"
              ]
            },
            {
              "name": "bulk_create",
              "docstring": "Create multiple records in a single transaction.\n\nArgs:\n    items: List of dictionaries with record data\n\nReturns:\n    List of created records\n\nRaises:\n    DatabaseError: If bulk creation fails",
              "args": [
                "self",
                "items"
              ]
            },
            {
              "name": "bulk_update",
              "docstring": "Update multiple records in a single transaction.\n\nArgs:\n    items: List of dictionaries with record data including ID\n\nReturns:\n    List of updated records\n\nRaises:\n    DatabaseError: If bulk update fails",
              "args": [
                "self",
                "items"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": [
        "T"
      ]
    },
    "database\\sqlalchemy\\core\\manager_factory.py": {
      "path": "database\\sqlalchemy\\core\\manager_factory.py",
      "imports": [
        "typing.Type",
        "typing.Dict",
        "typing.Any",
        "typing.TypeVar",
        "typing.Optional",
        "typing.Callable",
        "typing.Union",
        "typing.List",
        "sqlalchemy.orm.Session",
        "store_management.database.sqlalchemy.core.base_manager.BaseManager"
      ],
      "classes": [],
      "functions": [
        {
          "name": "register_specialized_manager",
          "docstring": "Register a specialized manager for a specific model class.\n\nArgs:\n    model_class: The SQLAlchemy model class\n    manager_class: The specialized manager class to use for this model",
          "args": [
            "model_class",
            "manager_class"
          ]
        },
        {
          "name": "get_manager",
          "docstring": "Get or create a manager for the specified model class.\n\nThis factory ensures only one manager is created per model class,\nwith support for specialized managers.\n\nArgs:\n    model_class: The SQLAlchemy model class\n    session_factory: Optional custom session factory (defaults to global session factory)\n    force_new: If True, create a new manager instance\n\nReturns:\n    A BaseManager instance for the model class",
          "args": [
            "model_class",
            "session_factory",
            "force_new"
          ]
        },
        {
          "name": "_create_manager",
          "docstring": "Create a new manager instance for the specified model class.\n\nArgs:\n    model_class: The SQLAlchemy model class\n    session_factory: Optional custom session factory\n\nReturns:\n    A BaseManager instance for the model class",
          "args": [
            "model_class",
            "session_factory"
          ]
        },
        {
          "name": "clear_manager_cache",
          "docstring": "Clear the manager instance cache.\n\nUseful for testing or resetting the application state.",
          "args": []
        }
      ],
      "global_variables": [
        "T",
        "_manager_cache",
        "_specialized_managers"
      ]
    },
    "database\\sqlalchemy\\core\\register_managers.py": {
      "path": "database\\sqlalchemy\\core\\register_managers.py",
      "imports": [
        "store_management.database.sqlalchemy.models.Storage",
        "store_management.database.sqlalchemy.models.Product",
        "store_management.database.sqlalchemy.models.Supplier",
        "store_management.database.sqlalchemy.models.Part",
        "store_management.database.sqlalchemy.models.Leather",
        "store_management.database.sqlalchemy.models.Recipe",
        "store_management.database.sqlalchemy.models.RecipeItem",
        "store_management.database.sqlalchemy.models.Order",
        "store_management.database.sqlalchemy.models.OrderItem",
        "store_management.database.sqlalchemy.models.ShoppingList",
        "store_management.database.sqlalchemy.models.ShoppingListItem",
        "store_management.database.sqlalchemy.core.manager_factory.register_specialized_manager",
        "store_management.database.sqlalchemy.core.specialized.storage_manager.StorageManager",
        "store_management.database.sqlalchemy.core.specialized.product_manager.ProductManager",
        "store_management.database.sqlalchemy.core.specialized.supplier_manager.SupplierManager",
        "store_management.database.sqlalchemy.core.specialized.part_manager.PartManager",
        "store_management.database.sqlalchemy.core.specialized.leather_manager.LeatherManager",
        "store_management.database.sqlalchemy.core.specialized.recipe_manager.RecipeManager",
        "store_management.database.sqlalchemy.core.specialized.order_manager.OrderManager",
        "store_management.database.sqlalchemy.core.specialized.shopping_list_manager.ShoppingListManager"
      ],
      "classes": [],
      "functions": [
        {
          "name": "register_all_specialized_managers",
          "docstring": "Register all specialized managers for models.\n\nThis should be called during application initialization.",
          "args": []
        }
      ],
      "global_variables": []
    },
    "database\\sqlalchemy\\core\\__init__.py": {
      "path": "database\\sqlalchemy\\core\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\managers\\incoming_goods_manager.py": {
      "path": "database\\sqlalchemy\\managers\\incoming_goods_manager.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "datetime.datetime",
        "store_management.database.sqlalchemy.models.Order",
        "store_management.database.sqlalchemy.models.OrderDetail",
        "store_management.database.sqlalchemy.models.Supplier",
        "store_management.database.sqlalchemy.models.Storage",
        "store_management.database.sqlalchemy.models.Product",
        "store_management.database.sqlalchemy.models.order.OrderStatus",
        "store_management.database.sqlalchemy.models.order.PaymentStatus",
        "store_management.database.sqlalchemy.session.get_session"
      ],
      "classes": [
        {
          "name": "IncomingGoodsManager",
          "docstring": "",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_order",
              "docstring": "Create a new order",
              "args": [
                "self",
                "data"
              ]
            },
            {
              "name": "get_all_orders",
              "docstring": "Get all orders",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_order_by_id",
              "docstring": "Get an order by its ID",
              "args": [
                "self",
                "order_id"
              ]
            },
            {
              "name": "get_order_by_number",
              "docstring": "Get an order by its order number",
              "args": [
                "self",
                "order_number"
              ]
            },
            {
              "name": "update_order",
              "docstring": "Update an order",
              "args": [
                "self",
                "order_id",
                "data"
              ]
            },
            {
              "name": "delete_order",
              "docstring": "Delete an order",
              "args": [
                "self",
                "order_id"
              ]
            },
            {
              "name": "add_order_detail",
              "docstring": "Add a detail to an order",
              "args": [
                "self",
                "order_id",
                "data"
              ]
            },
            {
              "name": "get_order_details",
              "docstring": "Get all details for an order",
              "args": [
                "self",
                "order_id"
              ]
            },
            {
              "name": "update_order_detail",
              "docstring": "Update an order detail",
              "args": [
                "self",
                "detail_id",
                "data"
              ]
            },
            {
              "name": "delete_order_detail",
              "docstring": "Delete an order detail",
              "args": [
                "self",
                "detail_id"
              ]
            },
            {
              "name": "get_suppliers",
              "docstring": "Get a list of supplier names",
              "args": [
                "self"
              ]
            },
            {
              "name": "update_inventory",
              "docstring": "Update inventory for a product",
              "args": [
                "self",
                "unique_id",
                "amount",
                "is_shelf"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\managers\\inventory_manager.py": {
      "path": "database\\sqlalchemy\\managers\\inventory_manager.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Union",
        "typing.Tuple",
        "datetime.datetime",
        "sqlalchemy.select",
        "sqlalchemy.and_",
        "sqlalchemy.or_",
        "sqlalchemy.func",
        "sqlalchemy.orm.joinedload",
        "sqlalchemy.exc.SQLAlchemyError",
        "store_management.database.sqlalchemy.base_manager.BaseManager",
        "store_management.database.sqlalchemy.models.Part",
        "store_management.database.sqlalchemy.models.Leather",
        "store_management.database.sqlalchemy.models.InventoryTransaction",
        "store_management.database.sqlalchemy.models.LeatherTransaction",
        "store_management.database.sqlalchemy.models.InventoryStatus",
        "store_management.database.sqlalchemy.models.TransactionType",
        "store_management.utils.error_handler.DatabaseError",
        "store_management.utils.logger.logger"
      ],
      "classes": [
        {
          "name": "InventoryManager",
          "docstring": "Comprehensive inventory manager handling both Part and Leather inventory.\nUses separate BaseManager instances for each model type.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize inventory managers with session factory.",
              "args": [
                "self",
                "session_factory"
              ]
            },
            {
              "name": "add_part",
              "docstring": "Add a new part to inventory.\n\nArgs:\n    data: Part data including initial stock levels\n\nReturns:\n    Created Part instance",
              "args": [
                "self",
                "data"
              ]
            },
            {
              "name": "add_leather",
              "docstring": "Add a new leather to inventory.\n\nArgs:\n    data: Leather data including initial area\n\nReturns:\n    Created Leather instance",
              "args": [
                "self",
                "data"
              ]
            },
            {
              "name": "update_part_stock",
              "docstring": "Update part stock levels with transaction tracking.\n\nArgs:\n    part_id: Part ID\n    quantity_change: Change in quantity (positive or negative)\n    transaction_type: Type of transaction\n    notes: Optional transaction notes\n\nReturns:\n    Updated Part instance",
              "args": [
                "self",
                "part_id",
                "quantity_change",
                "transaction_type",
                "notes"
              ]
            },
            {
              "name": "update_leather_stock",
              "docstring": "Update leather stock levels with transaction tracking.\n\nArgs:\n    leather_id: Leather ID\n    area_change: Change in area (positive or negative)\n    transaction_type: Type of transaction\n    notes: Optional transaction notes\n\nReturns:\n    Updated Leather instance",
              "args": [
                "self",
                "leather_id",
                "area_change",
                "transaction_type",
                "notes"
              ]
            },
            {
              "name": "get_part_with_transactions",
              "docstring": "Get part with its transaction history.\n\nArgs:\n    part_id: Part ID\n\nReturns:\n    Part instance with transactions loaded or None if not found",
              "args": [
                "self",
                "part_id"
              ]
            },
            {
              "name": "get_leather_with_transactions",
              "docstring": "Get leather with its transaction history.\n\nArgs:\n    leather_id: Leather ID\n\nReturns:\n    Leather instance with transactions loaded or None if not found",
              "args": [
                "self",
                "leather_id"
              ]
            },
            {
              "name": "get_low_stock_parts",
              "docstring": "Get all parts with low stock levels.\n\nArgs:\n    include_out_of_stock: Whether to include out of stock items\n\nReturns:\n    List of Part instances with low stock",
              "args": [
                "self",
                "include_out_of_stock"
              ]
            },
            {
              "name": "get_low_stock_leather",
              "docstring": "Get all leather with low stock levels.\n\nArgs:\n    include_out_of_stock: Whether to include out of stock items\n\nReturns:\n    List of Leather instances with low stock",
              "args": [
                "self",
                "include_out_of_stock"
              ]
            },
            {
              "name": "get_inventory_transactions",
              "docstring": "Get inventory transactions with optional filtering.\n\nArgs:\n    part_id: Optional Part ID to filter by\n    leather_id: Optional Leather ID to filter by\n    start_date: Optional start date for date range\n    end_date: Optional end date for date range\n\nReturns:\n    List of transaction instances",
              "args": [
                "self",
                "part_id",
                "leather_id",
                "start_date",
                "end_date"
              ]
            },
            {
              "name": "get_inventory_value",
              "docstring": "Calculate total value of inventory.\n\nReturns:\n    Dictionary with total values for parts and leather",
              "args": [
                "self"
              ]
            },
            {
              "name": "search_inventory",
              "docstring": "Search both parts and leather inventory.\n\nArgs:\n    search_term: Term to search for\n\nReturns:\n    Dictionary with matching parts and leather items",
              "args": [
                "self",
                "search_term"
              ]
            },
            {
              "name": "adjust_min_stock_levels",
              "docstring": "Adjust minimum stock level for a part.\n\nArgs:\n    part_id: Part ID\n    new_min_level: New minimum stock level\n\nReturns:\n    Updated Part instance",
              "args": [
                "self",
                "part_id",
                "new_min_level"
              ]
            },
            {
              "name": "adjust_min_leather_area",
              "docstring": "Adjust minimum area for a leather type.\n\nArgs:\n    leather_id: Leather ID\n    new_min_area: New minimum area in square feet\n\nReturns:\n    Updated Leather instance",
              "args": [
                "self",
                "leather_id",
                "new_min_area"
              ]
            },
            {
              "name": "get_inventory_summary",
              "docstring": "Get comprehensive inventory summary including counts and values.\n\nReturns:\n    Dictionary containing inventory summary statistics",
              "args": [
                "self"
              ]
            },
            {
              "name": "bulk_update_parts",
              "docstring": "Update multiple parts in a single transaction.\n\nArgs:\n    updates: List of dictionaries containing part updates\n\nReturns:\n    Number of parts updated",
              "args": [
                "self",
                "updates"
              ]
            },
            {
              "name": "bulk_update_leather",
              "docstring": "Update multiple leather items in a single transaction.\n\nArgs:\n    updates: List of dictionaries containing leather updates\n\nReturns:\n    Number of leather items updated",
              "args": [
                "self",
                "updates"
              ]
            },
            {
              "name": "get_transaction_history",
              "docstring": "Get transaction history with optional filtering.\n\nArgs:\n    start_date: Optional start date for filtering\n    end_date: Optional end date for filtering\n    transaction_type: Optional transaction type filter\n\nReturns:\n    Dictionary containing part and leather transactions",
              "args": [
                "self",
                "start_date",
                "end_date",
                "transaction_type"
              ]
            },
            {
              "name": "get_part_stock_history",
              "docstring": "Get stock level history for a part.\n\nArgs:\n    part_id: Part ID\n    days: Optional number of days to look back\n\nReturns:\n    List of stock level changes with timestamps",
              "args": [
                "self",
                "part_id",
                "days"
              ]
            },
            {
              "name": "get_leather_stock_history",
              "docstring": "Get stock level history for a leather item.\n\nArgs:\n    leather_id: Leather ID\n    days: Optional number of days to look back\n\nReturns:\n    List of stock level changes with timestamps",
              "args": [
                "self",
                "leather_id",
                "days"
              ]
            },
            {
              "name": "get_reorder_suggestions",
              "docstring": "Get suggestions for items that need reordering.\n\nReturns:\n    Dictionary containing parts and leather that need reordering",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\managers\\leather_inventory_manager.py": {
      "path": "database\\sqlalchemy\\managers\\leather_inventory_manager.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Tuple",
        "datetime.datetime",
        "sqlalchemy.select",
        "sqlalchemy.and_",
        "sqlalchemy.or_",
        "sqlalchemy.func",
        "sqlalchemy.case",
        "sqlalchemy.orm.joinedload",
        "sqlalchemy.exc.SQLAlchemyError",
        "store_management.database.sqlalchemy.base_manager.BaseManager",
        "store_management.database.sqlalchemy.models.Leather",
        "store_management.database.sqlalchemy.models.LeatherTransaction",
        "store_management.database.sqlalchemy.models.Supplier",
        "store_management.database.sqlalchemy.models.TransactionType",
        "store_management.database.sqlalchemy.models.InventoryStatus",
        "store_management.utils.error_handler.DatabaseError",
        "store_management.utils.logger.logger"
      ],
      "classes": [
        {
          "name": "LeatherInventoryManager",
          "docstring": "Specialized manager for leather inventory operations with area tracking.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize LeatherInventoryManager with session factory.",
              "args": [
                "self",
                "session_factory"
              ]
            },
            {
              "name": "add_leather",
              "docstring": "Add new leather to inventory with initial area tracking.\n\nArgs:\n    data: Leather data including initial area and supplier\n\nReturns:\n    Created Leather instance\n\nRaises:\n    DatabaseError: If validation fails or database operation fails",
              "args": [
                "self",
                "data"
              ]
            },
            {
              "name": "update_leather_area",
              "docstring": "Update leather area with transaction tracking and wastage calculation.\n\nArgs:\n    leather_id: Leather ID\n    area_change: Change in area (negative for consumption)\n    transaction_type: Type of transaction\n    notes: Optional transaction notes\n    wastage: Optional wastage area to track\n\nReturns:\n    Tuple of (updated Leather instance, created Transaction)\n\nRaises:\n    DatabaseError: If update fails or would result in negative area",
              "args": [
                "self",
                "leather_id",
                "area_change",
                "transaction_type",
                "notes",
                "wastage"
              ]
            },
            {
              "name": "get_leather_with_transactions",
              "docstring": "Get leather details with transaction history and optional wastage analysis.\n\nArgs:\n    leather_id: Leather ID\n    include_wastage: Whether to include wastage calculations\n\nReturns:\n    Dictionary with leather details and transaction history",
              "args": [
                "self",
                "leather_id",
                "include_wastage"
              ]
            },
            {
              "name": "get_low_stock_leather",
              "docstring": "Get leather items with low stock levels.\n\nArgs:\n    include_out_of_stock: Whether to include out of stock items\n    supplier_id: Optional supplier ID to filter by\n\nReturns:\n    List of Leather instances with low stock",
              "args": [
                "self",
                "include_out_of_stock",
                "supplier_id"
              ]
            },
            {
              "name": "calculate_leather_efficiency",
              "docstring": "Calculate leather usage efficiency metrics.\n\nArgs:\n    leather_id: Leather ID\n    date_range: Optional tuple of (start_date, end_date)\n\nReturns:\n    Dictionary containing efficiency metrics",
              "args": [
                "self",
                "leather_id",
                "date_range"
              ]
            },
            {
              "name": "adjust_minimum_area",
              "docstring": "Adjust minimum area threshold for a leather type.\n\nArgs:\n    leather_id: Leather ID\n    new_minimum: New minimum area threshold\n\nReturns:\n    Updated Leather instance",
              "args": [
                "self",
                "leather_id",
                "new_minimum"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\managers\\order_manager.py": {
      "path": "database\\sqlalchemy\\managers\\order_manager.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Union",
        "datetime.datetime",
        "sqlalchemy.select",
        "sqlalchemy.and_",
        "sqlalchemy.or_",
        "sqlalchemy.orm.joinedload",
        "store_management.database.sqlalchemy.base_manager.BaseManager",
        "store_management.database.sqlalchemy.models.Order",
        "store_management.database.sqlalchemy.models.OrderItem",
        "store_management.database.sqlalchemy.models.Part",
        "store_management.database.sqlalchemy.models.Leather",
        "store_management.utils.error_handler.DatabaseError",
        "store_management.utils.logger.logger"
      ],
      "classes": [
        {
          "name": "OrderManager",
          "docstring": "Enhanced order manager implementing specialized order operations\nwhile leveraging base manager functionality.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize OrderManager with session factory.",
              "args": [
                "self",
                "session_factory"
              ]
            },
            {
              "name": "create_order",
              "docstring": "Create a new order with items.\n\nArgs:\n    order_data: Dictionary containing order data\n    items: List of dictionaries containing order item data\n\nReturns:\n    Created Order instance\n\nRaises:\n    DatabaseError: If validation fails or database operation fails",
              "args": [
                "self",
                "order_data",
                "items"
              ]
            },
            {
              "name": "get_order_with_items",
              "docstring": "Get order with all its items.\n\nArgs:\n    order_id: Order ID\n\nReturns:\n    Order instance with items loaded or None if not found",
              "args": [
                "self",
                "order_id"
              ]
            },
            {
              "name": "update_order_status",
              "docstring": "Update order status with proper validation.\n\nArgs:\n    order_id: Order ID\n    status: New status\n\nReturns:\n    Updated Order instance or None if not found",
              "args": [
                "self",
                "order_id",
                "status"
              ]
            },
            {
              "name": "add_order_items",
              "docstring": "Add items to an existing order.\n\nArgs:\n    order_id: Order ID\n    items: List of dictionaries containing item data\n\nReturns:\n    Updated Order instance\n\nRaises:\n    DatabaseError: If order not found or validation fails",
              "args": [
                "self",
                "order_id",
                "items"
              ]
            },
            {
              "name": "remove_order_item",
              "docstring": "Remove an item from an order.\n\nArgs:\n    order_id: Order ID\n    item_id: Order Item ID\n\nReturns:\n    True if item was removed, False otherwise",
              "args": [
                "self",
                "order_id",
                "item_id"
              ]
            },
            {
              "name": "search_orders",
              "docstring": "Search orders by various fields.\n\nArgs:\n    search_term: Term to search for\n\nReturns:\n    List of matching Order instances",
              "args": [
                "self",
                "search_term"
              ]
            },
            {
              "name": "get_orders_by_date_range",
              "docstring": "Get orders within a date range.\n\nArgs:\n    start_date: Start date\n    end_date: End date\n\nReturns:\n    List of Order instances within the date range",
              "args": [
                "self",
                "start_date",
                "end_date"
              ]
            },
            {
              "name": "get_supplier_orders",
              "docstring": "Get all orders for a specific supplier.\n\nArgs:\n    supplier_id: Supplier ID\n\nReturns:\n    List of Order instances for the supplier",
              "args": [
                "self",
                "supplier_id"
              ]
            },
            {
              "name": "calculate_order_total",
              "docstring": "Calculate total value of an order.\n\nArgs:\n    order_id: Order ID\n\nReturns:\n    Total order value\n\nRaises:\n    DatabaseError: If order not found",
              "args": [
                "self",
                "order_id"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\managers\\production_order_manager.py": {
      "path": "database\\sqlalchemy\\managers\\production_order_manager.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Tuple",
        "datetime.datetime",
        "sqlalchemy.select",
        "sqlalchemy.and_",
        "sqlalchemy.or_",
        "sqlalchemy.func",
        "sqlalchemy.orm.joinedload",
        "sqlalchemy.exc.SQLAlchemyError",
        "store_management.database.sqlalchemy.base_manager.BaseManager",
        "store_management.database.sqlalchemy.models.ProductionOrder",
        "store_management.database.sqlalchemy.models.Recipe",
        "store_management.database.sqlalchemy.models.ProducedItem",
        "store_management.database.sqlalchemy.models.InventoryTransaction",
        "store_management.database.sqlalchemy.models.LeatherTransaction",
        "store_management.database.sqlalchemy.models.ProductionStatus",
        "store_management.database.sqlalchemy.models.TransactionType",
        "store_management.utils.error_handler.DatabaseError",
        "store_management.utils.logger.logger"
      ],
      "classes": [
        {
          "name": "ProductionOrderManager",
          "docstring": "Enhanced manager for production orders with recipe relationships.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize ProductionOrderManager with session factory.",
              "args": [
                "self",
                "session_factory"
              ]
            },
            {
              "name": "create_production_order",
              "docstring": "Create a new production order with recipe validation.\n\nArgs:\n    recipe_id: Recipe ID to produce\n    quantity: Number of items to produce\n    start_date: Optional planned start date\n    notes: Optional production notes\n\nReturns:\n    Created ProductionOrder instance\n\nRaises:\n    DatabaseError: If recipe not found or validation fails",
              "args": [
                "self",
                "recipe_id",
                "quantity",
                "start_date",
                "notes"
              ]
            },
            {
              "name": "start_production",
              "docstring": "Start a production order and reserve materials.\n\nArgs:\n    order_id: Production order ID\n    operator_notes: Optional notes from operator\n\nReturns:\n    Updated ProductionOrder instance",
              "args": [
                "self",
                "order_id",
                "operator_notes"
              ]
            },
            {
              "name": "_reserve_materials",
              "docstring": "Reserve materials for production through transactions.\n\nArgs:\n    session: Database session\n    order: ProductionOrder instance with loaded recipe",
              "args": [
                "self",
                "session",
                "order"
              ]
            },
            {
              "name": "complete_item",
              "docstring": "Record completion of a single produced item.\n\nArgs:\n    order_id: Production order ID\n    serial_number: Unique serial number for item\n    quality_check_passed: Whether item passed quality check\n    notes: Optional production notes\n\nReturns:\n    Created ProducedItem instance",
              "args": [
                "self",
                "order_id",
                "serial_number",
                "quality_check_passed",
                "notes"
              ]
            },
            {
              "name": "get_production_status",
              "docstring": "Get detailed production status including material usage.\n\nArgs:\n    order_id: Production order ID\n\nReturns:\n    Dictionary containing status details and metrics",
              "args": [
                "self",
                "order_id"
              ]
            },
            {
              "name": "get_active_orders",
              "docstring": "Get all active production orders with their recipes.\n\nReturns:\n    List of ProductionOrder instances with loaded relationships",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_production_metrics",
              "docstring": "Get production metrics for a date range.\n\nArgs:\n    start_date: Optional start date for filtering\n    end_date: Optional end date for filtering\n\nReturns:\n    Dictionary containing production metrics",
              "args": [
                "self",
                "start_date",
                "end_date"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\managers\\recipe_manager.py": {
      "path": "database\\sqlalchemy\\managers\\recipe_manager.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Tuple",
        "datetime.datetime",
        "sqlalchemy.select",
        "sqlalchemy.and_",
        "sqlalchemy.or_",
        "sqlalchemy.orm.joinedload",
        "sqlalchemy.exc.SQLAlchemyError",
        "store_management.database.sqlalchemy.base_manager.BaseManager",
        "store_management.database.sqlalchemy.models.Recipe",
        "store_management.database.sqlalchemy.models.RecipeItem",
        "store_management.database.sqlalchemy.models.Part",
        "store_management.database.sqlalchemy.models.Leather",
        "store_management.utils.error_handler.DatabaseError",
        "store_management.utils.logger.logger"
      ],
      "classes": [
        {
          "name": "RecipeManager",
          "docstring": "Recipe manager implementing specialized recipe operations\nwhile leveraging base manager functionality.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize RecipeManager with session factory.",
              "args": [
                "self",
                "session_factory"
              ]
            },
            {
              "name": "create_recipe",
              "docstring": "Create a new recipe with items.\n\nArgs:\n    recipe_data: Dictionary containing recipe data\n    items: List of dictionaries containing recipe item data\n\nReturns:\n    Created Recipe instance\n\nRaises:\n    DatabaseError: If validation fails or database operation fails",
              "args": [
                "self",
                "recipe_data",
                "items"
              ]
            },
            {
              "name": "get_recipe_with_items",
              "docstring": "Get recipe with all its items.\n\nArgs:\n    recipe_id: Recipe ID\n\nReturns:\n    Recipe instance with items loaded or None if not found",
              "args": [
                "self",
                "recipe_id"
              ]
            },
            {
              "name": "update_recipe_items",
              "docstring": "Update recipe items (replace existing items).\n\nArgs:\n    recipe_id: Recipe ID\n    items: New list of recipe items\n\nReturns:\n    Updated Recipe instance\n\nRaises:\n    DatabaseError: If recipe not found or validation fails",
              "args": [
                "self",
                "recipe_id",
                "items"
              ]
            },
            {
              "name": "add_recipe_item",
              "docstring": "Add a single item to a recipe.\n\nArgs:\n    recipe_id: Recipe ID\n    item_data: Dictionary containing item data\n\nReturns:\n    Created RecipeItem instance",
              "args": [
                "self",
                "recipe_id",
                "item_data"
              ]
            },
            {
              "name": "remove_recipe_item",
              "docstring": "Remove an item from a recipe.\n\nArgs:\n    recipe_id: Recipe ID\n    item_id: Recipe Item ID\n\nReturns:\n    True if item was removed, False otherwise",
              "args": [
                "self",
                "recipe_id",
                "item_id"
              ]
            },
            {
              "name": "update_recipe_item_quantity",
              "docstring": "Update the quantity of a recipe item.\n\nArgs:\n    recipe_id: Recipe ID\n    item_id: Recipe Item ID\n    quantity: New quantity\n\nReturns:\n    Updated RecipeItem instance",
              "args": [
                "self",
                "recipe_id",
                "item_id",
                "quantity"
              ]
            },
            {
              "name": "check_materials_availability",
              "docstring": "Check if all materials for a recipe are available in sufficient quantity.\n\nArgs:\n    recipe_id: Recipe ID\n    quantity: Number of items to produce\n\nReturns:\n    Tuple of (bool, list of missing items)",
              "args": [
                "self",
                "recipe_id",
                "quantity"
              ]
            },
            {
              "name": "get_recipes_by_type",
              "docstring": "Get all recipes of a specific type.\n\nArgs:\n    recipe_type: Type of recipe to filter by\n\nReturns:\n    List of matching Recipe instances",
              "args": [
                "self",
                "recipe_type"
              ]
            },
            {
              "name": "get_recipes_by_collection",
              "docstring": "Get all recipes in a specific collection.\n\nArgs:\n    collection: Collection name\n\nReturns:\n    List of matching Recipe instances",
              "args": [
                "self",
                "collection"
              ]
            },
            {
              "name": "search_recipes",
              "docstring": "Search recipes by various fields.\n\nArgs:\n    search_term: Term to search for\n\nReturns:\n    List of matching Recipe instances",
              "args": [
                "self",
                "search_term"
              ]
            },
            {
              "name": "duplicate_recipe",
              "docstring": "Create a duplicate of an existing recipe.\n\nArgs:\n    recipe_id: Source recipe ID\n    new_name: Name for the new recipe\n\nReturns:\n    New Recipe instance",
              "args": [
                "self",
                "recipe_id",
                "new_name"
              ]
            },
            {
              "name": "calculate_recipe_cost",
              "docstring": "Calculate the total cost of materials for a recipe.\n\nArgs:\n    recipe_id: Recipe ID\n\nReturns:\n    Total cost of all materials",
              "args": [
                "self",
                "recipe_id"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\managers\\report_manager.py": {
      "path": "database\\sqlalchemy\\managers\\report_manager.py",
      "imports": [
        "sqlalchemy.func",
        "sqlalchemy.and_",
        "sqlalchemy.orm.Session",
        "pandas",
        "datetime.datetime",
        "pdfkit",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "tkinter",
        "tkinter.ttk",
        "tkinter.messagebox",
        "datetime.datetime",
        "typing.Dict",
        "typing.Any"
      ],
      "classes": [
        {
          "name": "ReportManager",
          "docstring": "",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "session"
              ]
            },
            {
              "name": "generate_report",
              "docstring": "Generate a report based on type and optional filters.",
              "args": [
                "self",
                "report_type",
                "filters"
              ]
            },
            {
              "name": "generate_inventory_report",
              "docstring": "Generate inventory report with current stock levels.",
              "args": [
                "self",
                "filters"
              ]
            },
            {
              "name": "generate_products_report",
              "docstring": "Generate products report with recipe relationships.",
              "args": [
                "self",
                "filters"
              ]
            },
            {
              "name": "generate_low_stock_report",
              "docstring": "Generate report for items with stock below warning threshold.",
              "args": [
                "self",
                "filters"
              ]
            },
            {
              "name": "generate_recipe_usage_report",
              "docstring": "Generate report showing recipe usage in products.",
              "args": [
                "self",
                "filters"
              ]
            },
            {
              "name": "export_to_csv",
              "docstring": "Export report to CSV format.",
              "args": [
                "self",
                "df",
                "filename"
              ]
            },
            {
              "name": "export_to_excel",
              "docstring": "Export report to Excel format with formatting.",
              "args": [
                "self",
                "df",
                "filename"
              ]
            },
            {
              "name": "export_to_pdf",
              "docstring": "Export report to PDF format via HTML conversion.",
              "args": [
                "self",
                "df",
                "filename"
              ]
            }
          ],
          "base_classes": [
            "BaseManager"
          ]
        },
        {
          "name": "ReportDialog",
          "docstring": "",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "parent",
                "title"
              ]
            },
            {
              "name": "setup_ui",
              "docstring": "Setup the report dialog UI components.",
              "args": [
                "self"
              ]
            },
            {
              "name": "on_report_type_change",
              "docstring": "Update filters based on selected report type.",
              "args": [
                "self",
                "event"
              ]
            },
            {
              "name": "_add_filter",
              "docstring": "Add a filter widget to the filters frame.",
              "args": [
                "self",
                "name",
                "label",
                "widget_type"
              ]
            },
            {
              "name": "get_filters",
              "docstring": "Get current filter values.",
              "args": [
                "self"
              ]
            },
            {
              "name": "generate_report",
              "docstring": "Generate and export the selected report.",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "BaseDialog"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\managers\\shopping_list_manager.py": {
      "path": "database\\sqlalchemy\\managers\\shopping_list_manager.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Union",
        "typing.Tuple",
        "datetime.datetime",
        "sqlalchemy.select",
        "sqlalchemy.and_",
        "sqlalchemy.or_",
        "sqlalchemy.func",
        "sqlalchemy.orm.joinedload",
        "sqlalchemy.exc.SQLAlchemyError",
        "store_management.database.sqlalchemy.base_manager.BaseManager",
        "store_management.database.sqlalchemy.models.ShoppingList",
        "store_management.database.sqlalchemy.models.ShoppingListItem",
        "store_management.database.sqlalchemy.models.Part",
        "store_management.database.sqlalchemy.models.Leather",
        "store_management.database.sqlalchemy.models.Supplier",
        "store_management.utils.error_handler.DatabaseError",
        "store_management.utils.logger.logger"
      ],
      "classes": [
        {
          "name": "ShoppingListManager",
          "docstring": "Manager for handling shopping list operations and related functionality.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize ShoppingListManager with session factory.",
              "args": [
                "self",
                "session_factory"
              ]
            },
            {
              "name": "create_shopping_list",
              "docstring": "Create a new shopping list with optional items.\n\nArgs:\n    data: Shopping list data (name, description, etc.)\n    items: Optional list of shopping list items\n\nReturns:\n    Created ShoppingList instance\n\nRaises:\n    DatabaseError: If validation fails or database operation fails",
              "args": [
                "self",
                "data",
                "items"
              ]
            },
            {
              "name": "get_shopping_list_with_items",
              "docstring": "Get shopping list with all its items.\n\nArgs:\n    list_id: Shopping list ID\n\nReturns:\n    ShoppingList instance with items loaded or None if not found",
              "args": [
                "self",
                "list_id"
              ]
            },
            {
              "name": "add_shopping_list_item",
              "docstring": "Add an item to a shopping list.\n\nArgs:\n    list_id: Shopping list ID\n    item_data: Item data including quantity and supplier\n\nReturns:\n    Created ShoppingListItem instance",
              "args": [
                "self",
                "list_id",
                "item_data"
              ]
            },
            {
              "name": "update_shopping_list_status",
              "docstring": "Update shopping list status.\n\nArgs:\n    list_id: Shopping list ID\n    status: New status\n\nReturns:\n    Updated ShoppingList instance or None if not found",
              "args": [
                "self",
                "list_id",
                "status"
              ]
            },
            {
              "name": "mark_item_purchased",
              "docstring": "Mark a shopping list item as purchased.\n\nArgs:\n    list_id: Shopping list ID\n    item_id: Shopping list item ID\n    purchase_data: Purchase details including date and price\n\nReturns:\n    Updated ShoppingListItem instance or None if not found",
              "args": [
                "self",
                "list_id",
                "item_id",
                "purchase_data"
              ]
            },
            {
              "name": "get_pending_items",
              "docstring": "Get all pending (unpurchased) items across all shopping lists.\n\nReturns:\n    List of unpurchased ShoppingListItem instances",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_items_by_supplier",
              "docstring": "Get all shopping list items for a specific supplier.\n\nArgs:\n    supplier_id: Supplier ID\n\nReturns:\n    List of ShoppingListItem instances for the supplier",
              "args": [
                "self",
                "supplier_id"
              ]
            },
            {
              "name": "get_shopping_list_summary",
              "docstring": "Get summary statistics for a shopping list.\n\nArgs:\n    list_id: Shopping list ID\n\nReturns:\n    Dictionary containing summary statistics",
              "args": [
                "self",
                "list_id"
              ]
            },
            {
              "name": "search_shopping_lists",
              "docstring": "Search shopping lists across name and description.\n\nArgs:\n    search_term: Term to search for\n\nReturns:\n    List of matching ShoppingList instances",
              "args": [
                "self",
                "search_term"
              ]
            },
            {
              "name": "filter_shopping_lists",
              "docstring": "Filter shopping lists based on various criteria.\n\nArgs:\n    status: Optional status filter\n    priority: Optional priority filter\n    date_range: Optional tuple of (start_date, end_date)\n\nReturns:\n    List of filtered ShoppingList instances",
              "args": [
                "self",
                "status",
                "priority",
                "date_range"
              ]
            },
            {
              "name": "bulk_update_items",
              "docstring": "Bulk update shopping list items.\n\nArgs:\n    updates: List of dictionaries containing item updates\n    list_id: Optional shopping list ID to restrict updates to\n\nReturns:\n    Number of items updated",
              "args": [
                "self",
                "updates",
                "list_id"
              ]
            },
            {
              "name": "merge_shopping_lists",
              "docstring": "Merge multiple shopping lists into a target list.\n\nArgs:\n    source_ids: List of source shopping list IDs\n    target_id: Target shopping list ID\n\nReturns:\n    Updated target ShoppingList instance\n\nRaises:\n    DatabaseError: If any list is not found or merge fails",
              "args": [
                "self",
                "source_ids",
                "target_id"
              ]
            },
            {
              "name": "get_overdue_items",
              "docstring": "Get all overdue items from active shopping lists.\n\nReturns:\n    List of overdue ShoppingListItem instances",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\managers\\storage_manager.py": {
      "path": "database\\sqlalchemy\\managers\\storage_manager.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Union",
        "datetime.datetime",
        "sqlalchemy.select",
        "sqlalchemy.and_",
        "sqlalchemy.or_",
        "sqlalchemy.func",
        "sqlalchemy.orm.joinedload",
        "sqlalchemy.exc.SQLAlchemyError",
        "store_management.database.sqlalchemy.base_manager.BaseManager",
        "store_management.database.sqlalchemy.models.Storage",
        "store_management.database.sqlalchemy.models.Product",
        "store_management.database.sqlalchemy.models.Leather",
        "store_management.database.sqlalchemy.models.Part",
        "store_management.utils.error_handler.DatabaseError",
        "store_management.utils.logger.logger"
      ],
      "classes": [
        {
          "name": "StorageManager",
          "docstring": "Enhanced storage manager implementing specialized storage operations.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize storage manager with session factory.\n\nArgs:\n    session_factory: Function to create database sessions",
              "args": [
                "self",
                "session_factory"
              ]
            },
            {
              "name": "get_all_storage_locations",
              "docstring": "Retrieve all storage locations.\n\nReturns:\n    List[Storage]: List of all storage locations",
              "args": [
                "self"
              ]
            },
            {
              "name": "add_storage_location",
              "docstring": "Add a new storage location.\n\nArgs:\n    data: Dictionary containing storage location data\n        Required keys:\n        - location: str\n        - capacity: float\n        Optional keys:\n        - description: str\n        - status: str\n\nReturns:\n    Optional[Storage]: Added storage location or None if failed\n\nRaises:\n    DatabaseError: If validation fails or database operation fails",
              "args": [
                "self",
                "data"
              ]
            },
            {
              "name": "update_storage_location",
              "docstring": "Update a storage location.\n\nArgs:\n    location_id: ID of storage location to update\n    data: Dictionary containing update data\n\nReturns:\n    Optional[Storage]: Updated storage location or None if not found\n\nRaises:\n    DatabaseError: If validation fails or database operation fails",
              "args": [
                "self",
                "location_id",
                "data"
              ]
            },
            {
              "name": "delete_storage_location",
              "docstring": "Delete a storage location.\n\nArgs:\n    location_id: ID of storage location to delete\n\nReturns:\n    bool: True if deleted, False if not found\n\nRaises:\n    DatabaseError: If deletion fails or has dependent records",
              "args": [
                "self",
                "location_id"
              ]
            },
            {
              "name": "get_storage_with_items",
              "docstring": "Get storage location with all associated items.\n\nArgs:\n    storage_id: ID of storage location\n\nReturns:\n    Optional[Storage]: Storage with items loaded or None if not found",
              "args": [
                "self",
                "storage_id"
              ]
            },
            {
              "name": "get_available_storage",
              "docstring": "Get storage locations with available capacity.\n\nReturns:\n    List[Storage]: List of storage locations with space available",
              "args": [
                "self"
              ]
            },
            {
              "name": "search_storage",
              "docstring": "Search storage locations by location or description.\n\nArgs:\n    term: Search term\n\nReturns:\n    List[Storage]: List of matching storage locations",
              "args": [
                "self",
                "term"
              ]
            },
            {
              "name": "get_storage_status",
              "docstring": "Get detailed status of a storage location.\n\nArgs:\n    storage_id: ID of storage location\n\nReturns:\n    Dict containing:\n    - total_capacity: float\n    - used_capacity: float\n    - available_capacity: float\n    - item_count: int\n    - last_modified: datetime",
              "args": [
                "self",
                "storage_id"
              ]
            },
            {
              "name": "get_storage_utilization",
              "docstring": "Get utilization metrics for all storage locations.\n\nReturns:\n    List of dictionaries containing utilization metrics for each location",
              "args": [
                "self"
              ]
            },
            {
              "name": "bulk_update_storage",
              "docstring": "Update multiple storage locations in bulk.\n\nArgs:\n    updates: List of dictionaries containing:\n        - id: Storage location ID\n        - updates: Dictionary of fields to update\n\nReturns:\n    int: Number of storage locations updated",
              "args": [
                "self",
                "updates"
              ]
            }
          ],
          "base_classes": [
            "BaseManager"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\managers\\supplier_manager.py": {
      "path": "database\\sqlalchemy\\managers\\supplier_manager.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Tuple",
        "datetime.datetime",
        "sqlalchemy.select",
        "sqlalchemy.and_",
        "sqlalchemy.or_",
        "sqlalchemy.func",
        "sqlalchemy.orm.joinedload",
        "sqlalchemy.exc.SQLAlchemyError",
        "store_management.database.sqlalchemy.base_manager.BaseManager",
        "store_management.database.sqlalchemy.models.Supplier",
        "store_management.database.sqlalchemy.models.Order",
        "store_management.database.sqlalchemy.models.Part",
        "store_management.database.sqlalchemy.models.Leather",
        "store_management.utils.error_handler.DatabaseError",
        "store_management.utils.logger.logger"
      ],
      "classes": [
        {
          "name": "SupplierManager",
          "docstring": "Manager for handling supplier operations and relationships.\nIncludes supplier performance tracking and order history management.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize SupplierManager with session factory.",
              "args": [
                "self",
                "session_factory"
              ]
            },
            {
              "name": "create_supplier",
              "docstring": "Create a new supplier with validation.\n\nArgs:\n    data: Supplier data including contact information\n\nReturns:\n    Created Supplier instance\n\nRaises:\n    DatabaseError: If validation fails",
              "args": [
                "self",
                "data"
              ]
            },
            {
              "name": "update_supplier",
              "docstring": "Update supplier information.\n\nArgs:\n    supplier_id: Supplier ID\n    data: Updated supplier data\n\nReturns:\n    Updated Supplier instance or None if not found",
              "args": [
                "self",
                "supplier_id",
                "data"
              ]
            },
            {
              "name": "get_supplier_with_orders",
              "docstring": "Get supplier with their order history.\n\nArgs:\n    supplier_id: Supplier ID\n\nReturns:\n    Supplier instance with orders loaded or None if not found",
              "args": [
                "self",
                "supplier_id"
              ]
            },
            {
              "name": "get_supplier_products",
              "docstring": "Get all products supplied by a supplier.\n\nArgs:\n    supplier_id: Supplier ID\n\nReturns:\n    Dictionary containing parts and leather supplied",
              "args": [
                "self",
                "supplier_id"
              ]
            },
            {
              "name": "get_supplier_performance",
              "docstring": "Calculate supplier performance metrics.\n\nArgs:\n    supplier_id: Supplier ID\n\nReturns:\n    Dictionary containing performance metrics",
              "args": [
                "self",
                "supplier_id"
              ]
            },
            {
              "name": "update_supplier_rating",
              "docstring": "Update supplier quality rating.\n\nArgs:\n    supplier_id: Supplier ID\n    rating: New rating (0-5)\n    notes: Optional notes about the rating\n\nReturns:\n    Updated Supplier instance",
              "args": [
                "self",
                "supplier_id",
                "rating",
                "notes"
              ]
            },
            {
              "name": "get_supplier_order_history",
              "docstring": "Get supplier's order history with optional date range.\n\nArgs:\n    supplier_id: Supplier ID\n    start_date: Optional start date\n    end_date: Optional end date\n\nReturns:\n    List of Order instances",
              "args": [
                "self",
                "supplier_id",
                "start_date",
                "end_date"
              ]
            },
            {
              "name": "get_top_suppliers",
              "docstring": "Get top suppliers based on order volume and performance.\n\nArgs:\n    limit: Number of suppliers to return\n\nReturns:\n    List of supplier data with performance metrics",
              "args": [
                "self",
                "limit"
              ]
            },
            {
              "name": "get_supplier_categories",
              "docstring": "Get categories of products supplied by a supplier.\n\nArgs:\n    supplier_id: Supplier ID\n\nReturns:\n    List of unique product categories",
              "args": [
                "self",
                "supplier_id"
              ]
            },
            {
              "name": "search_suppliers",
              "docstring": "Search suppliers across multiple fields.\n\nArgs:\n    search_term: Term to search for\n\nReturns:\n    List of matching Supplier instances",
              "args": [
                "self",
                "search_term"
              ]
            },
            {
              "name": "get_supplier_statistics",
              "docstring": "Get overall supplier statistics.\n\nReturns:\n    Dictionary containing supplier statistics",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\managers\\__init__.py": {
      "path": "database\\sqlalchemy\\managers\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\migrations\\manager.py": {
      "path": "database\\sqlalchemy\\migrations\\manager.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "logging",
        "pathlib.Path",
        "datetime.datetime",
        "alembic.config",
        "alembic.command",
        "alembic.script.ScriptDirectory",
        "alembic.runtime.migration.MigrationContext",
        "sqlalchemy.create_engine",
        "sqlalchemy.inspect",
        "store_management.database.sqlalchemy.base_manager.BaseManager",
        "store_management.utils.error_handler.DatabaseError",
        "store_management.utils.logger.logger"
      ],
      "classes": [
        {
          "name": "MigrationManager",
          "docstring": "Handles database migrations and schema updates.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize migration manager.\n\nArgs:\n    database_url: Database connection URL\n    migrations_path: Optional custom path to migrations directory",
              "args": [
                "self",
                "database_url",
                "migrations_path"
              ]
            },
            {
              "name": "_create_alembic_config",
              "docstring": "Create Alembic configuration.",
              "args": [
                "self"
              ]
            },
            {
              "name": "check_current_version",
              "docstring": "Get current database version.\n\nReturns:\n    Current revision identifier",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_pending_migrations",
              "docstring": "Get list of pending migrations.\n\nReturns:\n    List of pending migration identifiers",
              "args": [
                "self"
              ]
            },
            {
              "name": "create_backup",
              "docstring": "Create database backup before migration.\n\nReturns:\n    Path to backup file",
              "args": [
                "self"
              ]
            },
            {
              "name": "run_migrations",
              "docstring": "Run pending migrations.\n\nArgs:\n    target: Target revision (defaults to latest)",
              "args": [
                "self",
                "target"
              ]
            },
            {
              "name": "revert_migration",
              "docstring": "Revert to a specific migration.\n\nArgs:\n    revision: Target revision to revert to",
              "args": [
                "self",
                "revision"
              ]
            },
            {
              "name": "verify_migration",
              "docstring": "Verify database schema matches models.\n\nReturns:\n    True if verification passes",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\migrations\\migration_manager.py": {
      "path": "database\\sqlalchemy\\migrations\\migration_manager.py",
      "imports": [
        "os",
        "sys",
        "logging.config.fileConfig",
        "typing.Optional",
        "typing.Union",
        "sqlalchemy.engine_from_config",
        "sqlalchemy.pool",
        "sqlalchemy.engine.Connection",
        "sqlalchemy.ext.declarative.DeclarativeMeta",
        "alembic.context"
      ],
      "classes": [
        {
          "name": "MigrationCLI",
          "docstring": "",
          "methods": [
            {
              "name": "create_migration",
              "docstring": "Create a new database migration\n\nArgs:\n    message (str): Description of migration changes",
              "args": [
                "message"
              ]
            },
            {
              "name": "upgrade",
              "docstring": "Upgrade database to specific or latest revision\n\nArgs:\n    revision (str, optional): Target migration revision. Defaults to 'head'.",
              "args": [
                "revision"
              ]
            },
            {
              "name": "downgrade",
              "docstring": "Downgrade database to previous migration\n\nArgs:\n    revision (str, optional): Target migration revision. Defaults to previous migration.",
              "args": [
                "revision"
              ]
            }
          ],
          "base_classes": []
        },
        {
          "name": "MigrationTracker",
          "docstring": "",
          "methods": [
            {
              "name": "get_current_version",
              "docstring": "Get current database migration version\n\nReturns:\n    str: Current migration revision",
              "args": []
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [
        {
          "name": "get_base_metadata",
          "docstring": "",
          "args": []
        },
        {
          "name": "run_migrations_offline",
          "docstring": "Run migrations in 'offline' mode.",
          "args": [
            "config",
            "target_metadata"
          ]
        },
        {
          "name": "run_migrations_online",
          "docstring": "Run migrations in 'online' mode.",
          "args": [
            "config",
            "target_metadata"
          ]
        },
        {
          "name": "main",
          "docstring": "Run database migrations with advanced configuration options.\n\nArgs:\n    config_file (Optional[str]): Path to Alembic configuration file.",
          "args": [
            "config_file"
          ]
        }
      ],
      "global_variables": [
        "project_root"
      ]
    },
    "database\\sqlalchemy\\migrations\\__init__.py": {
      "path": "database\\sqlalchemy\\migrations\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\mixins\\base_mixins.py": {
      "path": "database\\sqlalchemy\\mixins\\base_mixins.py",
      "imports": [
        "typing.TypeVar",
        "typing.Generic",
        "typing.Type",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "typing.Callable",
        "typing.Union",
        "sqlalchemy.orm.Session",
        "sqlalchemy.select",
        "sqlalchemy.or_",
        "sqlalchemy.and_",
        "sqlalchemy.func",
        "sqlalchemy.sql.expression.ColumnElement"
      ],
      "classes": [
        {
          "name": "BaseMixin",
          "docstring": "Base mixin providing core functionality for database managers.\n\nThis mixin serves as a foundational class for other database-related mixins,\nproviding common initialization and type safety.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the base mixin with a model class and session factory.\n\nArgs:\n    model_class: The SQLAlchemy model class this mixin operates on\n    session_factory: A callable that returns a database session",
              "args": [
                "self",
                "model_class",
                "session_factory"
              ]
            }
          ],
          "base_classes": []
        },
        {
          "name": "SearchMixin",
          "docstring": "Advanced search functionality for database managers.\n\nProvides comprehensive search capabilities across multiple fields\nwith flexible configuration.",
          "methods": [
            {
              "name": "search",
              "docstring": "Perform a comprehensive search across multiple fields.\n\nArgs:\n    search_term: The term to search for\n    fields: Optional list of fields to search.\n            If None, uses all string columns.\n\nReturns:\n    List of matching records",
              "args": [
                "self",
                "search_term",
                "fields"
              ]
            },
            {
              "name": "advanced_search",
              "docstring": "Perform an advanced search with multiple criteria.\n\nArgs:\n    criteria: Dictionary of field-operator-value criteria\n    Example: {\n        'name': {'op': 'like', 'value': '%Widget%'},\n        'stock_level': {'op': 'gt', 'value': 10}\n    }\n\nReturns:\n    List of matching records",
              "args": [
                "self",
                "criteria"
              ]
            }
          ],
          "base_classes": []
        },
        {
          "name": "FilterMixin",
          "docstring": "Advanced filtering capabilities for database managers.\n\nProvides methods for complex, flexible filtering of database records.",
          "methods": [
            {
              "name": "filter_by_multiple",
              "docstring": "Filter records by multiple exact match criteria.\n\nArgs:\n    filters: Dictionary of field-value pairs\n\nReturns:\n    List of matching records",
              "args": [
                "self",
                "filters"
              ]
            },
            {
              "name": "filter_with_or",
              "docstring": "Filter records with OR conditions for each field.\n\nArgs:\n    filters: Dictionary of field-values pairs where values is a list\n    Example: {'status': ['NEW', 'PENDING']}\n\nReturns:\n    List of matching records",
              "args": [
                "self",
                "filters"
              ]
            },
            {
              "name": "filter_complex",
              "docstring": "Execute a complex filter with custom conditions.\n\nArgs:\n    conditions: List of condition dictionaries\n    join_type: How to join conditions ('and' or 'or')\n\nReturns:\n    List of matching records",
              "args": [
                "self",
                "conditions",
                "join_type"
              ]
            }
          ],
          "base_classes": []
        },
        {
          "name": "PaginationMixin",
          "docstring": "Pagination support for database managers.\n\nProvides methods for retrieving paginated results with\noptional filtering and ordering.",
          "methods": [
            {
              "name": "get_paginated",
              "docstring": "Get paginated results with optional ordering and filtering.\n\nArgs:\n    page: Page number (1-based)\n    page_size: Number of records per page\n    order_by: Optional column to order by\n    filters: Optional filtering criteria\n\nReturns:\n    Pagination result dictionary",
              "args": [
                "self",
                "page",
                "page_size",
                "order_by",
                "filters"
              ]
            }
          ],
          "base_classes": []
        },
        {
          "name": "TransactionMixin",
          "docstring": "Transaction handling mixin for database managers.\n\nProvides methods for running operations within database transactions\nwith robust error handling.",
          "methods": [
            {
              "name": "run_in_transaction",
              "docstring": "Execute an operation within a database transaction.\n\nArgs:\n    operation: Function to execute within the transaction\n    *args: Positional arguments for the operation\n    **kwargs: Keyword arguments for the operation\n\nReturns:\n    Result of the operation\n\nRaises:\n    Exception: If the transaction fails",
              "args": [
                "self",
                "operation"
              ]
            },
            {
              "name": "execute_with_result",
              "docstring": "Execute an operation in a transaction and return a standard result.\n\nArgs:\n    operation: Function to execute\n    *args: Arguments for the operation\n    **kwargs: Keyword arguments for the operation\n\nReturns:\n    Dictionary with operation result",
              "args": [
                "self",
                "operation"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": [
        "T"
      ]
    },
    "database\\sqlalchemy\\mixins\\filter_mixin.py": {
      "path": "database\\sqlalchemy\\mixins\\filter_mixin.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Type",
        "typing.Any",
        "typing.Dict",
        "sqlalchemy.select",
        "sqlalchemy.and_",
        "sqlalchemy.or_",
        "sqlalchemy.func",
        "store_management.database.sqlalchemy.base.Base",
        "store_management.database.sqlalchemy.session.get_db_session"
      ],
      "classes": [
        {
          "name": "FilterMixin",
          "docstring": "Mixin providing advanced filtering functionality for managers.\n\nThis mixin expects the class to have:\n- model_class attribute (SQLAlchemy model class)",
          "methods": [
            {
              "name": "filter_by_multiple",
              "docstring": "Filter records by multiple criteria (AND condition).\n\nArgs:\n    filters: Dictionary of field-value pairs\n\nReturns:\n    List of matching records",
              "args": [
                "self",
                "filters"
              ]
            },
            {
              "name": "filter_with_or",
              "docstring": "Filter records with OR conditions for each field.\n\nArgs:\n    filters: Dictionary of field-values pairs where values is a list\n        Example: {'status': ['NEW', 'PENDING']}\n\nReturns:\n    List of matching records",
              "args": [
                "self",
                "filters"
              ]
            },
            {
              "name": "filter_complex",
              "docstring": "Execute a complex filter with custom conditions.\n\nArgs:\n    conditions: List of condition dictionaries\n        Example: [\n            {'field': 'status', 'op': 'eq', 'value': 'NEW'},\n            {'field': 'price', 'op': 'gt', 'value': 100}\n        ]\n    join_type: How to join conditions ('and' or 'or')\n\nReturns:\n    List of matching records",
              "args": [
                "self",
                "conditions",
                "join_type"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\mixins\\paginated_query_mixin.py": {
      "path": "database\\sqlalchemy\\mixins\\paginated_query_mixin.py",
      "imports": [
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "typing.Optional",
        "typing.Tuple",
        "sqlalchemy.select",
        "sqlalchemy.func",
        "store_management.database.sqlalchemy.session.get_db_session"
      ],
      "classes": [
        {
          "name": "PaginatedQueryMixin",
          "docstring": "Mixin providing pagination functionality for managers.\n\nThis mixin expects the class to have:\n- model_class attribute (SQLAlchemy model class)",
          "methods": [
            {
              "name": "get_paginated",
              "docstring": "Get records with pagination.\n\nArgs:\n    page: Page number (1-based)\n    page_size: Number of records per page\n    order_by: Optional column to order by\n    filters: Optional filtering criteria\n\nReturns:\n    Dictionary containing pagination info and results:\n    {\n        'items': List of records,\n        'page': Current page number,\n        'page_size': Number of records per page,\n        'total_items': Total number of records,\n        'total_pages': Total number of pages\n    }",
              "args": [
                "self",
                "page",
                "page_size",
                "order_by",
                "filters"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\mixins\\search_mixin.py": {
      "path": "database\\sqlalchemy\\mixins\\search_mixin.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Type",
        "typing.Any",
        "typing.Dict",
        "sqlalchemy.select",
        "sqlalchemy.or_",
        "sqlalchemy.func",
        "store_management.database.sqlalchemy.base.Base",
        "store_management.database.sqlalchemy.session.get_db_session"
      ],
      "classes": [
        {
          "name": "SearchMixin",
          "docstring": "Mixin providing advanced search functionality for managers.\n\nThis mixin expects the class to have:\n- model_class attribute (SQLAlchemy model class)",
          "methods": [
            {
              "name": "search",
              "docstring": "Search for records across multiple fields.\n\nArgs:\n    search_term: Term to search for\n    fields: Optional list of fields to search in (defaults to all string fields)\n\nReturns:\n    List of matching records",
              "args": [
                "self",
                "search_term",
                "fields"
              ]
            },
            {
              "name": "advanced_search",
              "docstring": "Perform an advanced search with multiple criteria.\n\nArgs:\n    criteria: Dictionary of field-operator-value criteria\n        Example: {'name': {'op': 'like', 'value': '%Widget%'},\n                  'stock_level': {'op': 'gt', 'value': 10}}\n\nReturns:\n    List of matching records",
              "args": [
                "self",
                "criteria"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\mixins\\test_mixin.py": {
      "path": "database\\sqlalchemy\\mixins\\test_mixin.py",
      "imports": [
        "pytest",
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.create_engine",
        "sqlalchemy.orm.declarative_base",
        "sqlalchemy.orm.sessionmaker",
        "typing.Dict",
        "typing.Any",
        "typing.List",
        "store_management.database.sqlalchemy.mixins.base_mixins.BaseMixin",
        "store_management.database.sqlalchemy.mixins.base_mixins.SearchMixin",
        "store_management.database.sqlalchemy.mixins.base_mixins.FilterMixin",
        "store_management.database.sqlalchemy.mixins.base_mixins.PaginationMixin",
        "store_management.database.sqlalchemy.mixins.base_mixins.TransactionMixin"
      ],
      "classes": [
        {
          "name": "TestModel",
          "docstring": "Test model for mixin testing.",
          "methods": [],
          "base_classes": [
            "TestBase"
          ]
        },
        {
          "name": "TestModelManager",
          "docstring": "Test manager combining all mixins.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "model_class",
                "session_factory"
              ]
            }
          ],
          "base_classes": [
            "SearchMixin",
            "FilterMixin",
            "PaginationMixin",
            "TransactionMixin"
          ]
        },
        {
          "name": "TestSearchMixin",
          "docstring": "Test suite for SearchMixin functionality.",
          "methods": [
            {
              "name": "test_basic_search",
              "docstring": "Test basic search across all string fields.",
              "args": [
                "self",
                "test_manager",
                "sample_data"
              ]
            },
            {
              "name": "test_advanced_search",
              "docstring": "Test advanced search with multiple criteria.",
              "args": [
                "self",
                "test_manager",
                "sample_data"
              ]
            }
          ],
          "base_classes": []
        },
        {
          "name": "TestFilterMixin",
          "docstring": "Test suite for FilterMixin functionality.",
          "methods": [
            {
              "name": "test_filter_by_multiple",
              "docstring": "Test filtering by multiple exact match criteria.",
              "args": [
                "self",
                "test_manager",
                "sample_data"
              ]
            },
            {
              "name": "test_filter_with_or",
              "docstring": "Test filtering with OR conditions.",
              "args": [
                "self",
                "test_manager",
                "sample_data"
              ]
            },
            {
              "name": "test_filter_complex",
              "docstring": "Test complex filtering with multiple conditions.",
              "args": [
                "self",
                "test_manager",
                "sample_data"
              ]
            }
          ],
          "base_classes": []
        },
        {
          "name": "TestPaginationMixin",
          "docstring": "Test suite for PaginationMixin functionality.",
          "methods": [
            {
              "name": "test_pagination_basic",
              "docstring": "Test basic pagination functionality.",
              "args": [
                "self",
                "test_manager",
                "session_factory"
              ]
            },
            {
              "name": "test_pagination_with_filters",
              "docstring": "Test pagination with filtering.",
              "args": [
                "self",
                "test_manager",
                "sample_data"
              ]
            }
          ],
          "base_classes": []
        },
        {
          "name": "TestTransactionMixin",
          "docstring": "Test suite for TransactionMixin functionality.",
          "methods": [
            {
              "name": "test_run_in_transaction_success",
              "docstring": "Test successful transaction.",
              "args": [
                "self",
                "test_manager"
              ]
            },
            {
              "name": "test_run_in_transaction_rollback",
              "docstring": "Test transaction rollback on error.",
              "args": [
                "self",
                "test_manager"
              ]
            },
            {
              "name": "test_execute_with_result",
              "docstring": "Test execute_with_result method.",
              "args": [
                "self",
                "test_manager"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [
        {
          "name": "test_engine",
          "docstring": "Create an in-memory SQLite database for testing.",
          "args": []
        },
        {
          "name": "session_factory",
          "docstring": "Create a session factory for testing.",
          "args": [
            "test_engine"
          ]
        },
        {
          "name": "test_manager",
          "docstring": "Create a test manager instance.",
          "args": [
            "session_factory"
          ]
        },
        {
          "name": "sample_data",
          "docstring": "Populate test database with sample data.",
          "args": [
            "test_manager"
          ]
        }
      ],
      "global_variables": [
        "TestBase"
      ]
    },
    "database\\sqlalchemy\\mixins\\test_mixin_perormance.py": {
      "path": "database\\sqlalchemy\\mixins\\test_mixin_perormance.py",
      "imports": [
        "pytest",
        "time",
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.create_engine",
        "sqlalchemy.select",
        "sqlalchemy.and_",
        "sqlalchemy.orm.declarative_base",
        "sqlalchemy.orm.sessionmaker",
        "typing.List",
        "typing.Dict",
        "typing.Any",
        "store_management.database.sqlalchemy.mixins.base_mixins.SearchMixin",
        "store_management.database.sqlalchemy.mixins.base_mixins.FilterMixin",
        "store_management.database.sqlalchemy.mixins.base_mixins.PaginationMixin"
      ],
      "classes": [
        {
          "name": "PerformanceTestModel",
          "docstring": "Large test model for performance benchmarking.",
          "methods": [],
          "base_classes": [
            "TestBase"
          ]
        },
        {
          "name": "PerformanceTestManager",
          "docstring": "Performance test manager combining mixins.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "",
              "args": [
                "self",
                "model_class",
                "session_factory"
              ]
            }
          ],
          "base_classes": [
            "SearchMixin",
            "FilterMixin",
            "PaginationMixin"
          ]
        },
        {
          "name": "TestMixinPerformance",
          "docstring": "Performance benchmarking for database mixins.",
          "methods": [
            {
              "name": "test_search_performance",
              "docstring": "Benchmark search performance.",
              "args": [
                "self",
                "performance_manager",
                "large_dataset"
              ]
            },
            {
              "name": "test_advanced_search_performance",
              "docstring": "Benchmark advanced search performance.",
              "args": [
                "self",
                "performance_manager",
                "large_dataset"
              ]
            },
            {
              "name": "test_filter_performance",
              "docstring": "Benchmark filtering performance.",
              "args": [
                "self",
                "performance_manager",
                "large_dataset"
              ]
            },
            {
              "name": "test_pagination_performance",
              "docstring": "Benchmark pagination performance.",
              "args": [
                "self",
                "performance_manager",
                "large_dataset"
              ]
            },
            {
              "name": "test_complex_filter_performance",
              "docstring": "Benchmark complex filtering performance.",
              "args": [
                "self",
                "performance_manager",
                "large_dataset"
              ]
            },
            {
              "name": "test_native_sqlalchemy_performance_comparison",
              "docstring": "Compare mixin performance with native SQLAlchemy query.",
              "args": [
                "self",
                "performance_manager",
                "large_dataset"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [
        {
          "name": "test_engine",
          "docstring": "Create an in-memory SQLite database for performance testing.",
          "args": []
        },
        {
          "name": "session_factory",
          "docstring": "Create a session factory for performance testing.",
          "args": [
            "test_engine"
          ]
        },
        {
          "name": "performance_manager",
          "docstring": "Create a performance test manager instance.",
          "args": [
            "session_factory"
          ]
        },
        {
          "name": "large_dataset",
          "docstring": "Populate test database with a large dataset.",
          "args": [
            "performance_manager"
          ]
        }
      ],
      "global_variables": [
        "TestBase"
      ]
    },
    "database\\sqlalchemy\\mixins\\transaction_mixin.py": {
      "path": "database\\sqlalchemy\\mixins\\transaction_mixin.py",
      "imports": [
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Type",
        "typing.TypeVar",
        "typing.Generic",
        "typing.Callable",
        "contextlib.contextmanager",
        "store_management.database.sqlalchemy.session.get_db_session"
      ],
      "classes": [
        {
          "name": "TransactionMixin",
          "docstring": "Mixin providing transaction handling for complex operations.\n\nThis mixin provides methods to run operations in transactions and handle errors.",
          "methods": [
            {
              "name": "run_in_transaction",
              "docstring": "Run operations in a transaction with error handling.\n\nUsage:\n    with self.run_in_transaction() as session:\n        # Perform operations\n\nYields:\n    SQLAlchemy session",
              "args": [
                "self"
              ]
            },
            {
              "name": "execute_with_result",
              "docstring": "Execute an operation in a transaction and return a standard result.\n\nArgs:\n    operation: Function to execute\n    *args: Arguments for the operation\n    **kwargs: Keyword arguments for the operation\n\nReturns:\n    Dictionary with operation result:\n    {\n        'success': True/False,\n        'data': Result data (if successful),\n        'error': Error message (if failed)\n    }",
              "args": [
                "self",
                "operation"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": [
        "T"
      ]
    },
    "database\\sqlalchemy\\mixins\\__init__.py": {
      "path": "database\\sqlalchemy\\mixins\\__init__.py",
      "imports": [
        "base_mixins.BaseMixin",
        "base_mixins.SearchMixin",
        "base_mixins.FilterMixin",
        "base_mixins.PaginationMixin",
        "base_mixins.TransactionMixin"
      ],
      "classes": [],
      "functions": [],
      "global_variables": [
        "__all__"
      ]
    },
    "database\\sqlalchemy\\models\\base.py": {
      "path": "database\\sqlalchemy\\models\\base.py",
      "imports": [
        "sqlalchemy.orm.DeclarativeBase",
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.DateTime",
        "datetime.datetime"
      ],
      "classes": [
        {
          "name": "Base",
          "docstring": "Base declarative model for all database models.\nProvides common fields and behaviors.",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "Default string representation of the model.\n\nReturns:\n    String representation with class name and ID",
              "args": [
                "self"
              ]
            },
            {
              "name": "to_dict",
              "docstring": "Convert model instance to dictionary.\n\nReturns:\n    Dictionary representation of the model",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "DeclarativeBase"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\models\\enums.py": {
      "path": "database\\sqlalchemy\\models\\enums.py",
      "imports": [
        "enum.Enum",
        "enum.auto"
      ],
      "classes": [
        {
          "name": "InventoryStatus",
          "docstring": "Inventory status for parts and materials.",
          "methods": [],
          "base_classes": [
            "Enum"
          ]
        },
        {
          "name": "ProductionStatus",
          "docstring": "Status of production processes.",
          "methods": [],
          "base_classes": [
            "Enum"
          ]
        },
        {
          "name": "TransactionType",
          "docstring": "Types of inventory transactions.",
          "methods": [],
          "base_classes": [
            "Enum"
          ]
        },
        {
          "name": "OrderStatus",
          "docstring": "Order processing status.",
          "methods": [],
          "base_classes": [
            "Enum"
          ]
        },
        {
          "name": "PaymentStatus",
          "docstring": "Payment processing status.",
          "methods": [],
          "base_classes": [
            "Enum"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\models\\leather.py": {
      "path": "database\\sqlalchemy\\models\\leather.py",
      "imports": [
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.Float",
        "sqlalchemy.DateTime",
        "sqlalchemy.ForeignKey",
        "sqlalchemy.Enum",
        "sqlalchemy.orm.relationship",
        "datetime.datetime",
        "store_management.database.sqlalchemy.base.Base",
        "store_management.database.sqlalchemy.models.enums.InventoryStatus"
      ],
      "classes": [
        {
          "name": "Leather",
          "docstring": "Leather model representing leather inventory items.\n\nAttributes:\n    id (int): Unique identifier for the leather\n    name (str): Name or identifier of the leather\n    type (str): Type or category of leather\n    color (str): Color of the leather\n    total_area (float): Total area of the leather\n    available_area (float): Currently available area\n    unit_price (float): Price per square unit\n    supplier_id (int): Foreign key to the supplier\n    status (InventoryStatus): Current inventory status\n    notes (str): Additional notes about the leather\n    created_at (datetime): Timestamp of record creation\n    updated_at (datetime): Timestamp of last update",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\models\\order.py": {
      "path": "database\\sqlalchemy\\models\\order.py",
      "imports": [
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.Float",
        "sqlalchemy.DateTime",
        "sqlalchemy.ForeignKey",
        "sqlalchemy.Enum",
        "sqlalchemy.Boolean",
        "sqlalchemy.orm.relationship",
        "datetime.datetime",
        "store_management.database.sqlalchemy.base.Base",
        "store_management.database.sqlalchemy.models.enums.OrderStatus",
        "store_management.database.sqlalchemy.models.enums.PaymentStatus"
      ],
      "classes": [
        {
          "name": "Order",
          "docstring": "Purchase order model representing orders in the system.\n\nAttributes:\n    id (int): Unique identifier for the order\n    order_number (str): Unique order number\n    supplier_id (int): Foreign key to the supplier\n    order_date (datetime): Date of order creation\n    expected_delivery_date (datetime): Expected delivery date\n    total_amount (float): Total order amount\n    status (OrderStatus): Current order status\n    payment_status (PaymentStatus): Current payment status\n    is_paid (bool): Whether the order is fully paid\n    notes (str): Additional notes about the order\n    created_at (datetime): Timestamp of record creation\n    updated_at (datetime): Timestamp of last update",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        },
        {
          "name": "OrderItem",
          "docstring": "Individual items within an order.\n\nAttributes:\n    id (int): Unique identifier for the order item\n    order_id (int): Foreign key to the parent order\n    part_id (int): Foreign key to the part\n    quantity (float): Quantity of the part ordered\n    unit_price (float): Price per unit\n    total_price (float): Total price for this item\n    notes (str): Additional notes about the item",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\models\\part.py": {
      "path": "database\\sqlalchemy\\models\\part.py",
      "imports": [
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.Float",
        "sqlalchemy.DateTime",
        "sqlalchemy.ForeignKey",
        "sqlalchemy.Enum",
        "sqlalchemy.orm.relationship",
        "datetime.datetime",
        "store_management.database.sqlalchemy.base.Base",
        "store_management.database.sqlalchemy.models.enums.InventoryStatus"
      ],
      "classes": [
        {
          "name": "Part",
          "docstring": "Part model representing inventory items.\n\nAttributes:\n    id (int): Unique identifier for the part\n    name (str): Name of the part\n    description (str): Detailed description of the part\n    stock_level (float): Current stock level of the part\n    min_stock_level (float): Minimum stock level threshold\n    unit_price (float): Price per unit\n    supplier_id (int): Foreign key to the supplier\n    status (InventoryStatus): Current inventory status\n    created_at (datetime): Timestamp of record creation\n    updated_at (datetime): Timestamp of last update",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\models\\product.py": {
      "path": "database\\sqlalchemy\\models\\product.py",
      "imports": [
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.Float",
        "sqlalchemy.ForeignKey",
        "sqlalchemy.orm.relationship",
        "store_management.database.sqlalchemy.base.Base"
      ],
      "classes": [
        {
          "name": "Product",
          "docstring": "Product model representing items that can be stored and manufactured.\n\nAttributes:\n    id (int): Unique identifier for the product\n    name (str): Name of the product\n    description (str): Detailed description of the product\n    category (str): Product category\n    unit_price (float): Price per unit\n    storage_id (int): Foreign key to the storage location",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\models\\recipe.py": {
      "path": "database\\sqlalchemy\\models\\recipe.py",
      "imports": [
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.Float",
        "sqlalchemy.DateTime",
        "sqlalchemy.ForeignKey",
        "sqlalchemy.orm.relationship",
        "datetime.datetime",
        "store_management.database.sqlalchemy.base.Base",
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.Float",
        "sqlalchemy.DateTime",
        "sqlalchemy.ForeignKey",
        "sqlalchemy.Boolean"
      ],
      "classes": [
        {
          "name": "Recipe",
          "docstring": "Recipe model representing product manufacturing recipes.\n\nAttributes:\n    id (int): Unique identifier for the recipe\n    name (str): Name of the recipe\n    description (str): Detailed description of the recipe\n    product_id (int): Foreign key to the product this recipe creates\n    estimated_production_time (float): Estimated time to produce\n    notes (str): Additional notes about the recipe\n    created_at (datetime): Timestamp of recipe creation\n    updated_at (datetime): Timestamp of last update",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        },
        {
          "name": "RecipeItem",
          "docstring": "Individual items required for a recipe.\n\nAttributes:\n    id (int): Unique identifier for the recipe item\n    recipe_id (int): Foreign key to the parent recipe\n    part_id (int): Foreign key to the part used in the recipe\n    leather_id (int): Foreign key to the leather used in the recipe\n    quantity (float): Quantity of the item needed\n    is_optional (bool): Whether the item is optional in the recipe\n    notes (str): Additional notes about the recipe item",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\models\\shopping_list.py": {
      "path": "database\\sqlalchemy\\models\\shopping_list.py",
      "imports": [
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.Float",
        "sqlalchemy.DateTime",
        "sqlalchemy.ForeignKey",
        "sqlalchemy.Boolean",
        "sqlalchemy.orm.relationship",
        "datetime.datetime",
        "store_management.database.sqlalchemy.base.Base"
      ],
      "classes": [
        {
          "name": "ShoppingList",
          "docstring": "Shopping List model for tracking items to be purchased.\n\nAttributes:\n    id (int): Unique identifier for the shopping list\n    name (str): Name or description of the shopping list\n    created_at (datetime): Timestamp of list creation\n    updated_at (datetime): Timestamp of last update\n    is_completed (bool): Whether the shopping list is completed\n    total_estimated_cost (float): Total estimated cost of items",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        },
        {
          "name": "ShoppingListItem",
          "docstring": "Individual items within a shopping list.\n\nAttributes:\n    id (int): Unique identifier for the shopping list item\n    shopping_list_id (int): Foreign key to the parent shopping list\n    part_id (int): Foreign key to the part (optional)\n    leather_id (int): Foreign key to the leather (optional)\n    quantity (float): Quantity of the item to be purchased\n    estimated_price (float): Estimated price of the item\n    is_purchased (bool): Whether the item has been purchased\n    supplier_id (int): Foreign key to the supplier\n    purchase_date (datetime): Date of purchase\n    actual_price (float): Actual price paid\n    notes (str): Additional notes about the item",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\models\\storage.py": {
      "path": "database\\sqlalchemy\\models\\storage.py",
      "imports": [
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.Float",
        "sqlalchemy.orm.relationship",
        "store_management.database.sqlalchemy.base.Base"
      ],
      "classes": [
        {
          "name": "Storage",
          "docstring": "Storage model representing storage locations.\n\nAttributes:\n    id (int): Unique identifier for the storage location\n    location (str): Specific location or name of the storage\n    description (str): Detailed description of the storage\n    capacity (float): Total capacity of the storage\n    current_usage (float): Current usage of the storage",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\models\\supplier.py": {
      "path": "database\\sqlalchemy\\models\\supplier.py",
      "imports": [
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.Float",
        "sqlalchemy.DateTime",
        "sqlalchemy.orm.relationship",
        "datetime.datetime",
        "store_management.database.sqlalchemy.base.Base"
      ],
      "classes": [
        {
          "name": "Supplier",
          "docstring": "Supplier model representing external suppliers.\n\nAttributes:\n    id (int): Unique identifier for the supplier\n    name (str): Name of the supplier\n    contact_name (str): Name of the primary contact\n    email (str): Contact email address\n    phone (str): Contact phone number\n    address (str): Supplier's physical address\n    rating (float): Supplier performance rating\n    notes (str): Additional notes about the supplier\n    created_at (datetime): Timestamp of record creation\n    updated_at (datetime): Timestamp of last update",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\models\\transaction.py": {
      "path": "database\\sqlalchemy\\models\\transaction.py",
      "imports": [
        "sqlalchemy.Column",
        "sqlalchemy.Integer",
        "sqlalchemy.String",
        "sqlalchemy.Float",
        "sqlalchemy.DateTime",
        "sqlalchemy.ForeignKey",
        "sqlalchemy.Enum",
        "sqlalchemy.orm.relationship",
        "datetime.datetime",
        "store_management.database.sqlalchemy.base.Base",
        "store_management.database.sqlalchemy.models.enums.TransactionType"
      ],
      "classes": [
        {
          "name": "InventoryTransaction",
          "docstring": "Transaction model for tracking part inventory changes.\n\nAttributes:\n    id (int): Unique identifier for the transaction\n    part_id (int): Foreign key to the part involved\n    quantity_change (float): Change in quantity (positive or negative)\n    transaction_type (TransactionType): Type of transaction\n    notes (str): Additional notes about the transaction\n    created_at (datetime): Timestamp of transaction creation",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        },
        {
          "name": "LeatherTransaction",
          "docstring": "Transaction model for tracking leather inventory changes.\n\nAttributes:\n    id (int): Unique identifier for the transaction\n    leather_id (int): Foreign key to the leather involved\n    area_change (float): Change in area (positive or negative)\n    transaction_type (TransactionType): Type of transaction\n    notes (str): Additional notes about the transaction\n    wastage (float): Area lost during transaction\n    created_at (datetime): Timestamp of transaction creation",
          "methods": [
            {
              "name": "__repr__",
              "docstring": "",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "Base"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\models\\__init__.py": {
      "path": "database\\sqlalchemy\\models\\__init__.py",
      "imports": [
        "base.Base",
        "enums.InventoryStatus",
        "enums.ProductionStatus",
        "enums.TransactionType",
        "enums.OrderStatus",
        "enums.PaymentStatus",
        "part.Part",
        "storage.Storage",
        "product.Product",
        "order.Order",
        "order.OrderItem",
        "supplier.Supplier",
        "recipe.Recipe",
        "recipe.RecipeItem",
        "shopping_list.ShoppingList",
        "shopping_list.ShoppingListItem",
        "leather.Leather",
        "transaction.InventoryTransaction",
        "transaction.LeatherTransaction"
      ],
      "classes": [],
      "functions": [],
      "global_variables": [
        "__all__"
      ]
    },
    "database\\sqlalchemy\\migrations\\versions\\202402201_add_relationships.py": {
      "path": "database\\sqlalchemy\\migrations\\versions\\202402201_add_relationships.py",
      "imports": [
        "alembic.op",
        "sqlalchemy",
        "datetime.datetime",
        "sqlalchemy.dialects.sqlite",
        "store_management.database.sqlalchemy.models.InventoryStatus",
        "store_management.database.sqlalchemy.models.ProductionStatus"
      ],
      "classes": [],
      "functions": [
        {
          "name": "upgrade",
          "docstring": "",
          "args": []
        },
        {
          "name": "downgrade",
          "docstring": "",
          "args": []
        }
      ],
      "global_variables": [
        "revision",
        "down_revision",
        "branch_labels",
        "depends_on"
      ]
    },
    "database\\sqlalchemy\\migrations\\versions\\463698485_comprehensive_model_relationships.py": {
      "path": "database\\sqlalchemy\\migrations\\versions\\463698485_comprehensive_model_relationships.py",
      "imports": [
        "alembic.op",
        "sqlalchemy",
        "sqlalchemy.dialects.sqlite",
        "enum.Enum",
        "store_management.database.sqlalchemy.models.InventoryStatus",
        "store_management.database.sqlalchemy.models.ProductionStatus",
        "store_management.database.sqlalchemy.models.TransactionType"
      ],
      "classes": [],
      "functions": [
        {
          "name": "upgrade",
          "docstring": "",
          "args": []
        },
        {
          "name": "downgrade",
          "docstring": "",
          "args": []
        }
      ],
      "global_variables": []
    },
    "database\\sqlalchemy\\migrations\\versions\\__init__.py": {
      "path": "database\\sqlalchemy\\migrations\\versions\\__init__.py",
      "imports": [],
      "classes": [],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\core\\specialized\\leather_manager.py": {
      "path": "database\\sqlalchemy\\core\\specialized\\leather_manager.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Tuple",
        "datetime.datetime",
        "sqlalchemy.select",
        "sqlalchemy.and_",
        "sqlalchemy.or_",
        "sqlalchemy.func",
        "sqlalchemy.orm.joinedload",
        "store_management.database.sqlalchemy.core.base_manager.BaseManager",
        "store_management.database.sqlalchemy.models.Leather",
        "store_management.database.sqlalchemy.models.LeatherTransaction",
        "store_management.database.sqlalchemy.models.InventoryStatus",
        "store_management.database.sqlalchemy.models.TransactionType",
        "store_management.utils.error_handling.DatabaseError"
      ],
      "classes": [
        {
          "name": "LeatherManager",
          "docstring": "Specialized manager for Leather model operations.\n\nExtends BaseManager with leather-specific operations.",
          "methods": [
            {
              "name": "get_leather_with_transactions",
              "docstring": "Get leather with its transaction history.\n\nArgs:\n    leather_id: Leather ID\n\nReturns:\n    Leather with transactions loaded or None if not found\n\nRaises:\n    DatabaseError: If retrieval fails",
              "args": [
                "self",
                "leather_id"
              ]
            },
            {
              "name": "update_leather_area",
              "docstring": "Update leather area with transaction tracking.\n\nArgs:\n    leather_id: Leather ID\n    area_change: Change in area (positive or negative)\n    transaction_type: Type of transaction\n    notes: Optional transaction notes\n    wastage: Optional wastage area\n\nReturns:\n    Tuple of (updated Leather, created Transaction)\n\nRaises:\n    DatabaseError: If update fails",
              "args": [
                "self",
                "leather_id",
                "area_change",
                "transaction_type",
                "notes",
                "wastage"
              ]
            },
            {
              "name": "get_low_stock_leather",
              "docstring": "Get leather items with low stock levels.\n\nArgs:\n    include_out_of_stock: Whether to include out of stock items\n\nReturns:\n    List of Leather instances with low stock\n\nRaises:\n    DatabaseError: If retrieval fails",
              "args": [
                "self",
                "include_out_of_stock"
              ]
            },
            {
              "name": "get_by_supplier",
              "docstring": "Get leather by supplier.\n\nArgs:\n    supplier_id: Supplier ID\n\nReturns:\n    List of leather from the specified supplier\n\nRaises:\n    DatabaseError: If retrieval fails",
              "args": [
                "self",
                "supplier_id"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\core\\specialized\\order_manager.py": {
      "path": "database\\sqlalchemy\\core\\specialized\\order_manager.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Callable",
        "sqlalchemy.orm.Session",
        "store_management.database.sqlalchemy.core.base_manager.BaseManager",
        "store_management.database.sqlalchemy.models.order.Order"
      ],
      "classes": [
        {
          "name": "OrderManager",
          "docstring": "Specialized manager for Order model operations.\n\nThis class extends BaseManager with order-specific operations.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the OrderManager.\n\nArgs:\n    session_factory: A callable that returns a SQLAlchemy Session.",
              "args": [
                "self",
                "session_factory"
              ]
            },
            {
              "name": "create_order",
              "docstring": "Create a new order.\n\nArgs:\n    order_data: Dictionary containing order information.\n\nReturns:\n    The created Order instance.",
              "args": [
                "self",
                "order_data"
              ]
            },
            {
              "name": "get_order_by_id",
              "docstring": "Retrieve an order by its ID.\n\nArgs:\n    order_id: The ID of the order to retrieve.\n\nReturns:\n    The Order instance if found, None otherwise.",
              "args": [
                "self",
                "order_id"
              ]
            },
            {
              "name": "get_all_orders",
              "docstring": "Retrieve all orders.\n\nReturns:\n    A list of all Order instances.",
              "args": [
                "self"
              ]
            }
          ],
          "base_classes": [
            "BaseManager"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\core\\specialized\\part_manager.py": {
      "path": "database\\sqlalchemy\\core\\specialized\\part_manager.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Tuple",
        "datetime.datetime",
        "sqlalchemy.select",
        "sqlalchemy.and_",
        "sqlalchemy.or_",
        "sqlalchemy.func",
        "sqlalchemy.orm.joinedload",
        "store_management.database.sqlalchemy.core.base_manager.BaseManager",
        "store_management.database.sqlalchemy.models.Part",
        "store_management.database.sqlalchemy.models.InventoryTransaction",
        "store_management.database.sqlalchemy.models.InventoryStatus",
        "store_management.database.sqlalchemy.models.TransactionType",
        "store_management.utils.error_handling.DatabaseError"
      ],
      "classes": [
        {
          "name": "PartManager",
          "docstring": "Specialized manager for Part model operations.\n\nExtends BaseManager with part-specific operations.",
          "methods": [
            {
              "name": "get_part_with_transactions",
              "docstring": "Get part with its transaction history.\n\nArgs:\n    part_id: Part ID\n\nReturns:\n    Part with transactions loaded or None if not found\n\nRaises:\n    DatabaseError: If retrieval fails",
              "args": [
                "self",
                "part_id"
              ]
            },
            {
              "name": "update_part_stock",
              "docstring": "Update part stock levels with transaction tracking.\n\nArgs:\n    part_id: Part ID\n    quantity_change: Change in quantity (positive or negative)\n    transaction_type: Type of transaction\n    notes: Optional transaction notes\n\nReturns:\n    Tuple of (updated Part, created Transaction)\n\nRaises:\n    DatabaseError: If update fails",
              "args": [
                "self",
                "part_id",
                "quantity_change",
                "transaction_type",
                "notes"
              ]
            },
            {
              "name": "get_low_stock_parts",
              "docstring": "Get all parts with low stock levels.\n\nArgs:\n    include_out_of_stock: Whether to include out of stock items\n\nReturns:\n    List of Part instances with low stock\n\nRaises:\n    DatabaseError: If retrieval fails",
              "args": [
                "self",
                "include_out_of_stock"
              ]
            },
            {
              "name": "get_by_supplier",
              "docstring": "Get parts by supplier.\n\nArgs:\n    supplier_id: Supplier ID\n\nReturns:\n    List of parts from the specified supplier\n\nRaises:\n    DatabaseError: If retrieval fails",
              "args": [
                "self",
                "supplier_id"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\core\\specialized\\product_manager.py": {
      "path": "database\\sqlalchemy\\core\\specialized\\product_manager.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "sqlalchemy.select",
        "sqlalchemy.and_",
        "sqlalchemy.or_",
        "sqlalchemy.func",
        "sqlalchemy.orm.joinedload",
        "store_management.database.sqlalchemy.core.base_manager.BaseManager",
        "store_management.database.sqlalchemy.models.Product",
        "store_management.database.sqlalchemy.models.Storage",
        "store_management.database.sqlalchemy.models.Recipe",
        "store_management.utils.error_handling.DatabaseError"
      ],
      "classes": [
        {
          "name": "ProductManager",
          "docstring": "Specialized manager for Product model operations.\n\nExtends BaseManager with product-specific operations.",
          "methods": [
            {
              "name": "get_product_with_recipe",
              "docstring": "Get product with its recipe.\n\nArgs:\n    product_id: Product ID\n\nReturns:\n    Product with recipe loaded or None if not found\n\nRaises:\n    DatabaseError: If retrieval fails",
              "args": [
                "self",
                "product_id"
              ]
            },
            {
              "name": "get_by_storage",
              "docstring": "Get products by storage location.\n\nArgs:\n    storage_id: Storage location ID\n\nReturns:\n    List of products in the specified storage\n\nRaises:\n    DatabaseError: If retrieval fails",
              "args": [
                "self",
                "storage_id"
              ]
            },
            {
              "name": "assign_to_storage",
              "docstring": "Assign a product to a storage location.\n\nArgs:\n    product_id: Product ID\n    storage_id: Storage location ID\n\nReturns:\n    Updated Product or None if not found\n\nRaises:\n    DatabaseError: If update fails",
              "args": [
                "self",
                "product_id",
                "storage_id"
              ]
            },
            {
              "name": "search_by_name",
              "docstring": "Search products by name.\n\nArgs:\n    name: Product name to search for\n\nReturns:\n    List of matching products\n\nRaises:\n    DatabaseError: If search fails",
              "args": [
                "self",
                "name"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\core\\specialized\\recipe_manager.py": {
      "path": "database\\sqlalchemy\\core\\specialized\\recipe_manager.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Tuple",
        "sqlalchemy.select",
        "sqlalchemy.and_",
        "sqlalchemy.or_",
        "sqlalchemy.func",
        "sqlalchemy.orm.joinedload",
        "store_management.database.sqlalchemy.core.base_manager.BaseManager",
        "store_management.database.sqlalchemy.models.Recipe",
        "store_management.database.sqlalchemy.models.RecipeItem",
        "store_management.database.sqlalchemy.models.Part",
        "store_management.database.sqlalchemy.models.Leather",
        "store_management.utils.error_handling.DatabaseError"
      ],
      "classes": [
        {
          "name": "RecipeManager",
          "docstring": "Specialized manager for Recipe model operations.\n\nExtends BaseManager with recipe-specific operations.",
          "methods": [
            {
              "name": "get_recipe_with_items",
              "docstring": "Get recipe with all its items.\n\nArgs:\n    recipe_id: Recipe ID\n\nReturns:\n    Recipe with items loaded or None if not found\n\nRaises:\n    DatabaseError: If retrieval fails",
              "args": [
                "self",
                "recipe_id"
              ]
            },
            {
              "name": "create_recipe",
              "docstring": "Create a new recipe with items.\n\nArgs:\n    recipe_data: Dictionary containing recipe data\n    items: List of dictionaries containing recipe item data\n\nReturns:\n    Created Recipe instance\n\nRaises:\n    DatabaseError: If creation fails",
              "args": [
                "self",
                "recipe_data",
                "items"
              ]
            },
            {
              "name": "update_recipe_items",
              "docstring": "Update recipe items (replace existing items).\n\nArgs:\n    recipe_id: Recipe ID\n    items: New list of recipe items\n\nReturns:\n    Updated Recipe instance\n\nRaises:\n    DatabaseError: If update fails",
              "args": [
                "self",
                "recipe_id",
                "items"
              ]
            },
            {
              "name": "add_recipe_item",
              "docstring": "Add a single item to a recipe.\n\nArgs:\n    recipe_id: Recipe ID\n    item_data: Dictionary containing item data\n\nReturns:\n    Created RecipeItem instance\n\nRaises:\n    DatabaseError: If creation fails",
              "args": [
                "self",
                "recipe_id",
                "item_data"
              ]
            },
            {
              "name": "check_materials_availability",
              "docstring": "Check if all materials for a recipe are available in sufficient quantity.\n\nArgs:\n    recipe_id: Recipe ID\n    quantity: Number of items to produce\n\nReturns:\n    Tuple of (all materials available, list of missing items)\n\nRaises:\n    DatabaseError: If check fails",
              "args": [
                "self",
                "recipe_id",
                "quantity"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\core\\specialized\\shopping_list_manager.py": {
      "path": "database\\sqlalchemy\\core\\specialized\\shopping_list_manager.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Tuple",
        "datetime.datetime",
        "sqlalchemy.select",
        "sqlalchemy.and_",
        "sqlalchemy.or_",
        "sqlalchemy.func",
        "sqlalchemy.orm.joinedload",
        "store_management.database.sqlalchemy.core.base_manager.BaseManager",
        "store_management.database.sqlalchemy.models.ShoppingList",
        "store_management.database.sqlalchemy.models.ShoppingListItem",
        "store_management.database.sqlalchemy.models.Supplier",
        "store_management.utils.error_handling.DatabaseError"
      ],
      "classes": [
        {
          "name": "ShoppingListManager",
          "docstring": "Specialized manager for ShoppingList model operations.\n\nExtends BaseManager with shopping list-specific operations.",
          "methods": [
            {
              "name": "get_shopping_list_with_items",
              "docstring": "Get shopping list with all its items.\n\nArgs:\n    list_id: Shopping list ID\n\nReturns:\n    ShoppingList with items loaded or None if not found\n\nRaises:\n    DatabaseError: If retrieval fails",
              "args": [
                "self",
                "list_id"
              ]
            },
            {
              "name": "create_shopping_list",
              "docstring": "Create a new shopping list with optional items.\n\nArgs:\n    data: Shopping list data\n    items: Optional list of item data\n\nReturns:\n    Created ShoppingList instance\n\nRaises:\n    DatabaseError: If creation fails",
              "args": [
                "self",
                "data",
                "items"
              ]
            },
            {
              "name": "add_shopping_list_item",
              "docstring": "Add an item to a shopping list.\n\nArgs:\n    list_id: Shopping list ID\n    item_data: Item data\n\nReturns:\n    Created ShoppingListItem instance\n\nRaises:\n    DatabaseError: If creation fails",
              "args": [
                "self",
                "list_id",
                "item_data"
              ]
            },
            {
              "name": "mark_item_purchased",
              "docstring": "Mark a shopping list item as purchased.\n\nArgs:\n    item_id: Shopping list item ID\n    purchase_data: Purchase details\n\nReturns:\n    Updated ShoppingListItem instance\n\nRaises:\n    DatabaseError: If update fails",
              "args": [
                "self",
                "item_id",
                "purchase_data"
              ]
            },
            {
              "name": "get_pending_items",
              "docstring": "Get all pending (unpurchased) items across all shopping lists.\n\nReturns:\n    List of unpurchased ShoppingListItem instances\n\nRaises:\n    DatabaseError: If retrieval fails",
              "args": [
                "self"
              ]
            },
            {
              "name": "get_items_by_supplier",
              "docstring": "Get all shopping list items for a specific supplier.\n\nArgs:\n    supplier_id: Supplier ID\n\nReturns:\n    List of ShoppingListItem instances for the supplier\n\nRaises:\n    DatabaseError: If retrieval fails",
              "args": [
                "self",
                "supplier_id"
              ]
            },
            {
              "name": "get_shopping_list_summary",
              "docstring": "Get summary statistics for a shopping list.\n\nArgs:\n    list_id: Shopping list ID\n\nReturns:\n    Dictionary containing summary statistics\n\nRaises:\n    DatabaseError: If retrieval fails",
              "args": [
                "self",
                "list_id"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\core\\specialized\\storage_manager.py": {
      "path": "database\\sqlalchemy\\core\\specialized\\storage_manager.py",
      "imports": [
        "typing.Callable",
        "sqlalchemy.orm.Session",
        "store_management.database.sqlalchemy.core.base_manager.BaseManager",
        "store_management.database.sqlalchemy.models.storage.Storage"
      ],
      "classes": [
        {
          "name": "StorageManager",
          "docstring": "Specialized manager for Storage model operations.\n\nThis class extends BaseManager with storage-specific operations.",
          "methods": [
            {
              "name": "__init__",
              "docstring": "Initialize the StorageManager.\n\nArgs:\n    session_factory: A callable that returns a SQLAlchemy Session.",
              "args": [
                "self",
                "session_factory"
              ]
            }
          ],
          "base_classes": [
            "BaseManager"
          ]
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\core\\specialized\\supplier_manager.py": {
      "path": "database\\sqlalchemy\\core\\specialized\\supplier_manager.py",
      "imports": [
        "typing.List",
        "typing.Optional",
        "typing.Dict",
        "typing.Any",
        "typing.Tuple",
        "datetime.datetime",
        "sqlalchemy.select",
        "sqlalchemy.and_",
        "sqlalchemy.or_",
        "sqlalchemy.func",
        "sqlalchemy.orm.joinedload",
        "store_management.database.sqlalchemy.core.base_manager.BaseManager",
        "store_management.database.sqlalchemy.models.Supplier",
        "store_management.database.sqlalchemy.models.Order",
        "store_management.database.sqlalchemy.models.Part",
        "store_management.database.sqlalchemy.models.Leather",
        "store_management.utils.error_handling.DatabaseError"
      ],
      "classes": [
        {
          "name": "SupplierManager",
          "docstring": "Specialized manager for Supplier model operations.\n\nExtends BaseManager with supplier-specific operations.",
          "methods": [
            {
              "name": "get_supplier_with_orders",
              "docstring": "Get supplier with their order history.\n\nArgs:\n    supplier_id: Supplier ID\n\nReturns:\n    Supplier with orders loaded or None if not found\n\nRaises:\n    DatabaseError: If retrieval fails",
              "args": [
                "self",
                "supplier_id"
              ]
            },
            {
              "name": "get_supplier_products",
              "docstring": "Get all products supplied by a supplier.\n\nArgs:\n    supplier_id: Supplier ID\n\nReturns:\n    Dictionary containing parts and leather supplied\n\nRaises:\n    DatabaseError: If retrieval fails",
              "args": [
                "self",
                "supplier_id"
              ]
            },
            {
              "name": "get_supplier_order_history",
              "docstring": "Get supplier's order history with optional date range.\n\nArgs:\n    supplier_id: Supplier ID\n    start_date: Optional start date\n    end_date: Optional end date\n\nReturns:\n    List of Order instances\n\nRaises:\n    DatabaseError: If retrieval fails",
              "args": [
                "self",
                "supplier_id",
                "start_date",
                "end_date"
              ]
            },
            {
              "name": "update_supplier_rating",
              "docstring": "Update supplier quality rating.\n\nArgs:\n    supplier_id: Supplier ID\n    rating: New rating (0-5)\n    notes: Optional notes about the rating\n\nReturns:\n    Updated Supplier instance\n\nRaises:\n    DatabaseError: If update fails",
              "args": [
                "self",
                "supplier_id",
                "rating",
                "notes"
              ]
            },
            {
              "name": "search_suppliers",
              "docstring": "Search suppliers across multiple fields.\n\nArgs:\n    term: Term to search for\n\nReturns:\n    List of matching Supplier instances\n\nRaises:\n    DatabaseError: If search fails",
              "args": [
                "self",
                "term"
              ]
            }
          ],
          "base_classes": []
        }
      ],
      "functions": [],
      "global_variables": []
    },
    "database\\sqlalchemy\\core\\specialized\\__init__.py": {
      "path": "database\\sqlalchemy\\core\\specialized\\__init__.py",
      "imports": [
        "storage_manager.StorageManager",
        "supplier_manager.SupplierManager",
        "product_manager.ProductManager",
        "part_manager.PartManager",
        "leather_manager.LeatherManager",
        "recipe_manager.RecipeManager",
        "order_manager.OrderManager",
        "shopping_list_manager.ShoppingListManager"
      ],
      "classes": [],
      "functions": [],
      "global_variables": [
        "__all__"
      ]
    }
  }
}